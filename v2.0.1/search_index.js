var documenterSearchIndex = {"docs":
[{"location":"internalfunctions/#Internal-Functions","page":"Internal Functions","title":"Internal Functions","text":"","category":"section"},{"location":"internalfunctions/","page":"Internal Functions","title":"Internal Functions","text":"CurrentModule = BoltzmannCollisionIntegral\nusing BoltzmannCollisionIntegral\nend","category":"page"},{"location":"internalfunctions/","page":"Internal Functions","title":"Internal Functions","text":"Modules = [BoltzmannCollisionIntegral]","category":"page"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.DoesConserve-NTuple{5, Any}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.DoesConserve","text":"DoesConserve(SMatrix,TMatrix,Parameters)\n\nFunction prints the ratio of the sum of the S and T matricies and their differences, for all interaction paths, as to check number and energy conservation for a particular interaction. Arguments are as outputted by the fload_All function. \n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.InvarientFlux-Tuple{Float64, Float64, Float64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.InvarientFlux","text":"InvarientFlux(s,mu12,mu22)\n\nreturns the value of the invarient flux with 's' mandelstram variable and masses 'mass1' and 'mass2'\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.InvarientFlux2-Tuple{Float64, Float64, Float64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.InvarientFlux2","text":"InvarientFlux2(s,mass12,mass22)\n\nreturns the value of the squared invarient flux with 's' mandelstram variable and masses 'mass1' and 'mass2'\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.InvarientFlux2Small-Tuple{Float64, Float64, Float64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.InvarientFlux2Small","text":"InvarientFluxSmall(sSmol,mass12,mass22)\n\nreturns the value of the squared invarient flux with smalled 's' mandelstram variable (sSmol = s - (m1+m2)^2)\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.InvarientFluxSmall-Tuple{Float64, Float64, Float64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.InvarientFluxSmall","text":"InvarientFluxSmall(sSmol,mu12,mu22)\n\nreturns the value of the invarient flux with smalled 's' mandelstram variable (sSmol = s - (m1+m2)^2)\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.Momentum3Value!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vararg{Float64, 4}}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.Momentum3Value!","text":"Momentum3Value!(p3v,p3pv,p1v,p2v)\n\nTakes set of random initial particle states 'p1v' and 'p2v' and random output states angles 'p3v[2:3]' and modifies outputs 'p3v' and 'p3pv' values with calculated output momentum and corrects angles if momentum is negative. Function also returns a two bools 'p3physical' and 'p3pphysical' indicating if p3 and p3p are physical momentum states given the inputs.  Function also returns a Int 'NumStates' indicating the number of valid output states found.\n\nRequrires normalised masses (mu1,mu2,mu3,mu4) to be defined in advance in Init.jl as const.\n\nExamples\n\njulia> mu1 = 1836.1528e0\njulia> mu2 = 1836.1528e0\njulia> mu3 = 1836.1528e0\njulia> mu4 = 1836.1528e0\njulia> p1v = [1e0, 0.5e0, 1.8e0]\njulia> p2v = [2e0, 0.2e0, 0.7e0]\njulia> p3v = [0e0, 0.3e0, 0.7e0]\njulia> p3pv = zeros(Float64,3)\njulia> p3pv .= p3v\njulia> Momentum3Value!(p3v,p3pv,p1v,p2v,mu1,mu2,mu3,mu4)\n(true,true,2)\njulia> p3v\n 3-element Vector{Float64}:\n 2.04505\n 0.3\n 0.7\njulia> p3pv\n 3-element Vector{Float64}\n 0.691423\n -0.3\n 1.7\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.PhaseSpaceFactors1!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Bool}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.PhaseSpaceFactors1!","text":"PhaseSpaceFactors1!(SMatrix3,SMatrix4,TMatrix,t3val,t4val,p1val,t1val,p2val,t2val,Indeistinguishable_12)\n\nApplies phase space volume element factors for 'SMatrix' and 'TMatrix' terms in order to correctly apply 'STSymmetry' corrections. \n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.PhaseSpaceFactors2!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Array{Float64, 4}, Vararg{Vector{Float64}, 8}}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.PhaseSpaceFactors2!","text":"PhaseSpaceFactors2!(SMatrix3,SMatrix4,TMatrix,p3val,t3val,p4val,t4val,p1val,t1val,p2val,t2val)\n\nTo follow 'PhaseSpaceFactors1' and 'STSymmetry'. Corrects phase space factors on 'SMatrix' and 'TMatrix' for use in kinetic codes. Assumes f(x,p,μ)= constant\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.PhaseSpaceFactorsSync1!-Tuple{Array{Float64, 4}, Vararg{Vector{Float64}, 4}}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.PhaseSpaceFactorsSync1!","text":"PhaseSpaceFactorsSync1!(SMatrix,p1val,t1val,p2val,t2val)\n\nApplies phase space volume element factors for 'SMatrix' terms in order to correctly apply 'SyncSymmetry' corrections. \n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.PhaseSpaceFactorsSync2!-Tuple{Array{Float64, 4}, Vector{Float64}, Vector{Float64}}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.PhaseSpaceFactorsSync2!","text":"PhaseSpaceFactorsSync2!(SMatrix,p1val,t1val)\n\nTo follow 'PhaseSpaceFactorsSync1' and 'SyncSymmetry'. Correct phase spcae factors on 'SMatrix' for use in kinetic codes. \n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.RPointLogMomentum!-Tuple{Vector{Float64}, Float64, Float64, Int64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.RPointLogMomentum!","text":"RPointLogMomentum!(pu,pl,pv,num)\n\nEdits the first element of pv with a random real-space momentum value between 10^pl and 10^pu. This sample is chosen by first randomly picking a momentum bin in the range 1:num and then uniformly sampling a momentum point in real-space (rather than log10 space) between pl and pu which are the momentum values at start and end of that bin. Sampling is done such there will be a constant number of points per momentum-space volume. As the momentum space between 10^pl and 10^pu it is a spherical shell hence the correct sampling is p = (U*(10^pu)^3+(1-U)*(10^pl)^3)^13 with uniform U  01.\n\nAssumes f(xpμ)=f(xvecp)*(2πp^2)=const in bin, therefore momentum space volume element is mathrmdp and as such uniform sampling corresponds to U*10^u+(1-U)*10^l where U is a uniform random number between 0 and 1.\n\nIf instead f(xvecp)=const in bin, momentum space volume element is p^2 mathrmdp and uniform sampling corresponds to (10^pu)*sqrt3U+(1-U)*10^3pl-3pu where U is a uniform random number between 0 and 1.\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.RPointSphereCosTheta!-Tuple{Vector{Float64}}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.RPointSphereCosTheta!","text":"RPointSphereTheta!()\n\nAssigns the second (cos(theta)) element of 'a' with a randomly, uniformly sampled values of spherical angles cos(theta). \n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.RPointSphereCosThetaPhi!-Tuple{Vector{Float64}}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.RPointSphereCosThetaPhi!","text":"RPointSphereThetaPhi!()\n\nAssigns the second (cos(theta)) and third (phi) elements of 'a' with a randomly, uniformly sampled values of spherical angles cos(theta) and phi (phi normalised by pi). \n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.STMonteCarloAxi_MultiThread!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Array{UInt32, 5}, Array{UInt32, 5}, Array{UInt32, 4}, Any, Array{Float64, 5}, Array{Float64, 5}, Array{Float64, 6}, Array{Float64, 6}, Function, Function, Tuple{Float64, Float64, Float64, Float64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Vararg{Int64, 5}}, Int64, Int64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.STMonteCarloAxi_MultiThread!","text":"STMonteCarloAxi_MultiThread!(SAtotal3,SAtotal4,TAtotal,SAtally3,SAtally4,TAtally,p3Max,t3MinMax,p4Max,t4MinMax,sigma,dsigmadt,Parameters,numTiterPerThread,numSiterPerThread)\n\nArguments\n\nSAtotal3::Array{Float64,6} : Array of stored integration totals for S matrix for 12->34 interaction\nSAtotal4::Array{Float64,6} : Array of stored integration totals for S matrix for 12->43 interaction\nTAtotal::Array{Float64,4} : Array of stored integration totals for T matrix\nSAtally3::Array{UInt32,5} : Array of stored integration tallies for S matrix for 12->34 interaction\nSAtally4::Array{UInt32,5} : Array of stored integration tallies for S matrix for 12->43 interaction\nTAtally::Array{UInt32,4} : Array of stored integration tallies for T matrix\np3Max::Array{Float64,5} : Array of maximum momentum values for species 3\nt3MinMax::Array{Float64,6} : Array of minimum and maximum theta values for species 3\np4Max::Array{Float64,5} : Array of maximum momentum values for species 4\nt4MinMax::Array{Float64,6} : Array of minimum and maximum theta values for species 4\nsigma::Function : Cross section function for the interaction\ndsigmadt::Function : Differential cross section function for the interaction\nParameters::Tuple{Float64,Float64,Float64,Float64,Float64,Float64,Int64,Float64,Float64,Int64,Float64,Float64,Int64,Float64,Float64,Int64,Int64,Int64,Int64,Int64} : Tuple of parameters for the interaction\nnumTiterPerThread::Int64 : Number of T iterations per thread\nnumSiterPerThread::Int64 : Number of S iterations per thread\n\nOutput:\n\nArgument arrays SAtotal,TAtotal,SAtally,TAtally are mutated to include the results of the Monte Carlo Integration.\n\nCalculation In Breif\n\nSet up worker threads\nRandom Sample points in each of these domains\nRandomPointSphere for theta and phi (for species 1,2,3,4)\nRandomPointMomentum for p ( species 1,2 only)\nTake random points (t3,h3,p1,p2,t1,t2,h1,h2) and calculate valid p3 point/points \nFind position in local S and T arrays and allocated tallies and totals accordingly.\nTake random points (t4,h3,p1,p2,t1,t2,h1,h2) and calculate valid p4 point/points \nFind position in local S and T arrays and allocated tallies and totals accordingly.\nUpdate global S and T arrays with locks to prevent data races\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.STMonteCarloAxi_Serial!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Array{UInt32, 5}, Array{UInt32, 5}, Array{UInt32, 4}, Array{Float64, 5}, Array{Float64, 5}, Array{Float64, 6}, Array{Float64, 6}, Function, Function, Tuple{Float64, Float64, Float64, Float64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Vararg{Int64, 5}}, Int64, Int64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.STMonteCarloAxi_Serial!","text":"STMonteCarloAxi_Serial!(SAtotal3,SAtotal4,TAtotal,SAtally3,SAtally4,TAtally,p3Max,p4Max,t3MinMax,t4MinMax,sigma,dsigmadt,Parameters,numTiter,numSiter)\n\nArguments\n\nSAtotal3::Array{Float64,6} : Array of stored integration totals for S matrix for 12->34 interaction\nSAtotal4::Array{Float64,6} : Array of stored integration totals for S matrix for 12->43 interaction\nTAtotal::Array{Float64,4} : Array of stored integration totals for T matrix\nSAtally3::Array{UInt32,5} : Array of stored integration tallies for S matrix for 12->34 interaction\nSAtally4::Array{UInt32,5} : Array of stored integration tallies for S matrix for 12->43 interaction\nTAtally::Array{UInt32,4} : Array of stored integration tallies for T matrix\np3Max::Array{Float64,5} : Array of maximum momentum values for species 3\nt3MinMax::Array{Float64,6} : Array of minimum and maximum theta values for species 3\np4Max::Array{Float64,5} : Array of maximum momentum values for species 4\nt4MinMax::Array{Float64,6} : Array of minimum and maximum theta values for species 4\nsigma::Function : Cross section function for the interaction\ndsigmadt::Function : Differential cross section function for the interaction\nParameters::Tuple{Float64,Float64,Float64,Float64,Float64,Float64,Int64,Float64,Float64,Int64,Float64,Float64,Int64,Float64,Float64,Int64,Int64,Int64,Int64,Int64} : Tuple of parameters for the interaction\nnumTiter::Int64 : Number of T iterations\nnumSiter::Int64 : Number of S iterations\n\nOutput:\n\nArgument arrays SAtotal,TAtotal,SAtally,TAtally are mutated to include the results of the Monte Carlo Integration.\n\nCalculation In Breif\n\nRandom Sample points in each of these domains\nRandomPointSphere for theta and phi (for species 1,2,3,4)\nRandomPointMomentum for p ( species 1,2 only)\nTake random points (t3,h3,p1,p2,t1,t2,h1,h2) and calculate valid p3 point/points \nFind position in local S and T arrays and allocated tallies and totals accordingly.\nTake random points (t4,h3,p1,p2,t1,t2,h1,h2) and calculate valid p4 point/points \nFind position in local S and T arrays and allocated tallies and totals accordingly.\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.STSymmetry!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Float64, Float64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.STSymmetry!","text":"STSymmetry!(SMatrix3,SMatrix4,TMatrix,t3val,mu1,mu2)\n\nTo follow 'PhaseSpaceFactors1'. Physical nature of binary interaction has certain symmetries. 'STSymmetry' uses these symmetries to improve MC sampling of 'SMatrix' and 'TMatrix'.\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.SValue3-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Function, Vararg{Float64, 4}}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.SValue3","text":"SValue3(p3v,p1v,p2v,dsigmadt,mu1,mu2,mu3)\n\nReturns Sval from MC integration based on initial momentum states p1v and p2v and final state p3v and differential cross section dsigmadt based on particle selection 12->34.   Assumes f(x,p,μ)=constant over bin\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.SValue4-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Function, Vararg{Float64, 4}}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.SValue4","text":"SValue4(p3v,p1v,p2v,dsigmadt,mu1,mu2,mu3)\n\nReturns Sval from MC integration based on initial momentum states p1v and p2v and final state p4v and differential cross section dsigmadt based on particle selection 12->34.   Assumes f(x,p,μ)=constant over bin\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.SpectraEvaluateMultiThread-Tuple{Tuple{String, String, String, String, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, String, String}}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.SpectraEvaluateMultiThread","text":"SpectraEvaluateMultiThread(userInputMultiThread)\n\nFunction to run the Monte Carlo integration of the S and T arrays in a multi-threaded environment. The function will run the Monte Carlo integration in parallel across the number of threads specified in the global variable nThreads. The function will then calculate the S and T matricies and save the results to a file.\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.SpectraEvaluateSerial-Tuple{Tuple{String, String, String, String, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, String, String}}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.SpectraEvaluateSerial","text":"SpectraEvaluateSerial(userInputSerial)\n\nFunction to run the Monte Carlo integration of the S and T arrays in a serial environment. The function will run the Monte Carlo integration in serial and then calculate the S and T matricies and save the results to a file.\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.SyncEvaluateMultiThread-Tuple{Any}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.SyncEvaluateMultiThread","text":"SyncEvaluateMultiThread!(userSyncInputMultiThread)\n\nFunction to run the Monte Carlo integration of the S array in a serial enviroment. \n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.SyncEvaluateSerial-Tuple{Any}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.SyncEvaluateSerial","text":"SyncEvaluateSerial!(userSyncInputSerial)\n\nFunction to run the Monte Carlo integration of the S array in a serial enviroment. \n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.SyncMonteCarloAxi_MultiThread!-Tuple{Array{Float64, 4}, Array{UInt32, 4}, Any, Tuple{Float64, Float64, Float64, Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}, Int64, Int64, Int64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.SyncMonteCarloAxi_MultiThread!","text":"SyncMonteCarloAxi_MultiThread!(SAtotal,SAtally,pMax,tMinMax,Parameters,numSiter)\n\nArguments\n\nSAtotal::Array{Float64,4} : Array of stored integration totals for S matrix for 2+B->2+B+1 interaction\nSAtally::Array{UInt32,4} : Array of stored integration tallies for S matrix for 2+B->2+B+1 interaction\npMax::Array{Float64,3} : Array of maximum momentum values for species 2\ntMinMax::Array{Float64,3} : Array of minimum and maximum theta values for species 2\nParameters::Tuple{Float64,Float64,Float64,Int64,Float64,Float64,Int64,Int64,Int64} : Tuple of parameters for the interaction\nnumSiter::Int64 : Number of S iterations\n\nOutput:\n\nArgument arrays SAtotal,SAtally are mutated to include the results of the Monte Carlo Integration.\n\nCalculation In Breif\n\nRandom Sample points in each of these domains\nRandomPointSphere for theta (for species 1,2)\nRandomPointMomentum for p ( species 1,2)\nTake random points (p1,p2,t1,t2) and calculate Synchrotron emissivity\nFind position in S arrays and allocated tallies and totals accordingly.\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.SyncMonteCarloAxi_Serial!-Tuple{Array{Float64, 4}, Array{UInt32, 4}, Tuple{Float64, Float64, Float64, Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}, Int64, Int64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.SyncMonteCarloAxi_Serial!","text":"SyncMonteCarloAxi_Serial!(SAtotal,SAtally,pMax,tMinMax,Parameters,numSiter)\n\nArguments\n\nSAtotal::Array{Float64,4} : Array of stored integration totals for S matrix for 2+B->2+B+1 interaction\nSAtally::Array{UInt32,4} : Array of stored integration tallies for S matrix for 2+B->2+B+1 interaction\npMax::Array{Float64,3} : Array of maximum momentum values for species 2\ntMinMax::Array{Float64,3} : Array of minimum and maximum theta values for species 2\nParameters::Tuple{Float64,Float64,Float64,Int64,Float64,Float64,Int64,Int64,Int64} : Tuple of parameters for the interaction\nnumSiter::Int64 : Number of S iterations\n\nOutput:\n\nArgument arrays SAtotal,SAtally are mutated to include the results of the Monte Carlo Integration.\n\nCalculation In Breif\n\nRandom Sample points in each of these domains\nRandomPointSphere for theta (for species 1,2)\nRandomPointMomentum for p ( species 1,2)\nTake random points (p1,p2,t1,t2) and calculate Synchrotron emissivity\nFind position in S arrays and allocated tallies and totals accordingly.\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.SyncSymmetry!-Tuple{Array{Float64, 4}}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.SyncSymmetry!","text":"SyncSymmetry!(SMatrix)\n\nTo follow 'PhaseSpaceFactorsSync1'. Synchrotron emission has a symmetry with respect to cos(theta) -> -cos(theta) for both initial particle and photon momenta.\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.TValue-Tuple{Vector{Float64}, Vector{Float64}, Function, Vararg{Float64, 4}}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.TValue","text":"TValue(p1v,p2v,sigma,mu1,mu2)\n\nreturns Tval with its Tval from MC integration based on initial momentum states p1v and p2v and cross section sigma based on particle selection. If initial state fails sCheck, i.e. cannot generate a physical output state, Tval is set to 0e0.  Assumes f(x,p,μ)=constant over bin\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.deltaEVector-Union{Tuple{T}, Tuple{Vector{T}, T}} where T<:Union{Float32, Float64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.deltaEVector","text":"deltaEVector(pr,mu)\n\nInputs a num+1 long Vector{Float} of p grid boundries and the particle mu value (normalised mass) and returns a num long Vector{Float} of average energy values per grid cell.\n\nExamples\n\njulia> deltaEVector([1.0e0, 10.0e0, 100.0e0, 1000.0e0], 1.0e0)\n3-element Vector{Float64}:\n 50.600693\n 4951.15\n 495001.16\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.deltaEkinVector-Union{Tuple{T}, Tuple{Vector{T}, T}} where T<:Union{Float32, Float64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.deltaEkinVector","text":"deltaEkinVector(pr,mu)\n\nInputs a num+1 long Vector{Float} of p grid boundries and the particle mu value (normalised mass) and returns a num long Vector{Float} of average kinetic energy values per grid cell.\n\nExamples\n\njulia> deltaEkinVector([1.0e0, 10.0e0, 100.0e0, 1000.0e0], 1.0e0)\n3-element Vector{Float64}:\n     46.10069600605712\n   4906.1506753523645\n 494551.15128635924\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.deltaVector-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Union{Float32, Float64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.deltaVector","text":"deltaVector(valr)\n\nInputs a num+1 long Vector{Float} quantitiy values (domain bounds) and returns a num long Vector{Float} of differeces (domain widths).\n\nExamples\n\njulia> deltaVector([1.0e0, 10.0e0, 100.0e0, 1000.0e0])\n3-element Vector{Float64}:\n 9.0\n 90.0\n 900.0\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.dsigmadt_ElePhoElePho-NTuple{6, Float64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.dsigmadt_ElePhoElePho","text":"dsigmadt_ElePhoElePho(sSmol,sBig,tSmol,tBig,uSmol,uBig)\n\nreturns the differential cross section for electron-photon scattering (Compton) scattering. Berestetskii 1982 (86.6). Masses and momenta are normalised by the rest mass of the electron m_textEle and the cross section is normalised by σ_T.\n\nfracdsigma_egammarightarrow egammadt(st)=frac3(s-1)^2leftleft(frac1s-1+frac1u-1right)^2+left(frac1s-1+frac1u-1right)-frac14left(fracs-1u-1+fracu-1s-1right)right\n\nArguments\n\nsSmol::Float64 : s - sBig\nsBig::Float64 : (m_1+m_2)^2 = 1  s = sSmol + 1\ntSmol::Float64 : t - tBig\ntBig::Float64 : (m_3-m_1)^2 = 0  t = tSmol\nuSmol::Float64 : u - uBig\nuBig::Float64 : (m_2-m_3)^2 = 1  u = uSmol + 1\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho-NTuple{6, Float64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho","text":"dsigmadt_ElePosPhoPho(sSmol,sBig,tSmol,tBig,uSmol,uBig)\n\nreturns the differential cross section for electron positron annihilation to two photons. Berestetskii 1982 (88.4). Masses and momenta are normalised by the rest mass of the electron m_textEle and the cross section is normalised by σ_T.\n\nfracdσ_e^+e^-rightarrowgammagammadt = -frac3s(s-4)left(left(frac1t-1+frac1u-1right)^2+left(frac1t-1+frac1u-1right)-frac14left(fract-1u-1+fracu-1t-1right)right)\n\nArguments\n\nsSmol::Float64 : s - sBig\nsBig::Float64 : (m_1+m_2)^2 = 4  s = sSmol + 4\ntSmol::Float64 : t - tBig\ntBig::Float64 : (m_3-m_1)^2 = 1  t = tSmol + 1\nuSmol::Float64 : u - uBig\nuBig::Float64 : (m2-m3)^2 = 1  u = uSmol + 1\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos-NTuple{6, Float64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos","text":"dsigmadt_PhoPhoElePos(sSmol,sBig,tSmol,tBig,uSmol,uBig)\n\nreturns the differential cross section for photon-photon annihilation to electron-positron pair. (Inverse proceess of electron positron annihilation to two photons). Masses and momenta are normalised by the rest mass of the electron m_textEle and the cross section is normalised by σ_T.\n\nfracdσ_gammagammarightarrow e^+e^-dt = -frac3s^2left(left(frac1t-1+frac1u-1right)^2+left(frac1t-1+frac1u-1right)-frac14left(fract-1u-1+fracu-1t-1right)right)\n\nArguments\n\nsSmol::Float64 : s - sBig\nsBig::Float64 : (m_1+m_2)^2 = 0  s = sSmol\ntSmol::Float64 : t - tBig\ntBig::Float64 : (m_3-m_1)^2 = 1  t = tSmol + 1\nuSmol::Float64 : u - uBig\nuBig::Float64 : (m_2-m_3)^2 = 1  u = uSmol + 1\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph-NTuple{6, Float64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph","text":"dsigmadt_SphSphSphSph(sSmol,sBig,tSmol,tBig,uSmol,uBig)\n\nreturns the differential cross section for the binary interaction of hard spheres with normalised masses m_1m_2m_3m_4=m_textSph. Normalised by πR_Sph^2.\n\nfracdσdt = frac1s-4m_textSph^2\n\nArguments\n\nsSmol::Float64 : s - sBig\nsBig::Float64 : (m_1+m_2)^2=4m_textSph^2\ntSmol::Float64 : t - tBig\ntBig::Float64 : (m_3-m_1)^2=0\nuSmol::Float64 : u - uBig\nuBig::Float64 : (m_2-m_3)^2=0\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.fload_All-Tuple{String, String}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.fload_All","text":"fload_All(fileLocation,fileName)\n\nLoads all the data stored in fileName stored at fileLocation.\n\nExample\n\n    (Run_Parameters,SAtot3,SAtot4,TAtot,SAtal3,SAtal4,TAtal,SMatrix3,SMatrix4,TMatrix1,TMatrix2,p3Max,p4Max,t3MinMax,t4MinMax,SConv3,SConv4,TConv) = fload_All(fileLocation,fileName);\n\nReturns a tuple of the data stored in the file. The fields are as follows:\n\nRun_Parameters : A tuple of the parameters used in the evaluation.\nStot3 : A 6D matrix totalling all the emission spectrum values sampled for 12->34 interaction.\nStot4 : A 6D matrix totalling all the emission spectrum values sampled for 12->43 interaction.\nTtot : A 4D matrix totalling all the absorption spectrum values sampled.\nStal3 : A 5D matrix of tallies of the number of emission spectrum values sampled for 12->34 interaction.\nStal4 : A 5D matrix of tallies of the number of emission spectrum values sampled for 12->43 interaction.\nTtal : A 4D matrix of tallies of the number of absorption spectrum values sampled.\nSMatrix3 : A 6D matrix of the emission spectrum for 12->34 interaction.\nSMatrix4 : A 6D matrix of the emission spectrum for 12->43 interaction.\nTMatrix1 : A 4D matrix of the absorption spectrum for 12->34 interaction.\nTMatrix2 : A 4D matrix of the absorption spectrum for 21->34 interaction i.e. by permutation of TMatrix1 and correct application of phase space factors if species 1 != species 2.\np3Max : The maximum value of the momentum space variable p3 sampled for each bin. (Useful for correcting numerical diffusion)\nt3MinMax : The minimum and maximum values of the momentum space variable t3 sampled for each bin. (Useful for correcting numerical diffusion)\np4Max : The maximum value of the momentum space variable p4 sampled for each bin. (Useful for correcting numerical diffusion)\nt4MinMax : The minimum and maximum values of the momentum space variable t4 sampled for each bin. (Useful for correcting numerical diffusion)\nSConv3 : A 6D matrix of the convergence of the emission spectrum compared to the previous run with given Run_Parameters for 12->34 interaction.\nSConv4 : A 6D matrix of the convergence of the emission spectrum compared to the previous run with given Run_Parameters for 12->43 interaction.\nTConv : A 4D matrix of the convergence of the absorption spectrum compared to the previous run with given Run_Parameters.\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.fload_All_Sync-Tuple{String, String}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.fload_All_Sync","text":"fload_All_Sync(fileLocation,fileName)\n\nLoads all the data stored in fileName stored at fileLocation.\n\nExample\n\n    (Run_Parameters,SAtot,SAtal,SMatrix,#=pMax,tMinMax,=#SConv) = fload_All_Sync(fileLocation,fileName);\n\nReturns a tuple of the data stored in the file. The fields are as follows:\n\nRun_Parameters : A tuple of the parameters used in the evaluation.\nStot : A 4D matrix totalling all the synchrotron emission spectrum values\nStal : A 4D matrix of tallies of the number of synchrotron emission spectrum values sampled\nSMatrix : A 4D matrix of the synchrotron emission spectrum.\npMax : The maximum value of the momentum space variable p1 (photon mommentum) sampled for each bin. (Useful for correcting numerical diffusion)\ntMinMax : The minimum and maximum values of the momentum space variable t1 sampled for each bin. (Useful for correcting numerical diffusion)\nSConv : A 4D matrix of the convergence of the synchrotron emission spectrum compared to the previous run with given Run_Parameters.\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.fload_Matrix-Tuple{String, String}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.fload_Matrix","text":"fload_Matrix(fileLocation,fileName)\n\nLoads just the S and T Matricies stored in fileName stored at fileLocation.\n\nExample\n\n    Matricies = fload_All(fileLocation,fileName);\n\nReturns a tuple of the data stored in the file. The fields are as follows:\n\nSMatrix3 : A 6D matrix of the emission spectrum for 12->34 interaction.\nSMatrix4 : A 6D matrix of the emission spectrum for 12->43 interaction.\nTMatrix1 : A 4D matrix of the absorption spectrum for 12->34 interaction.\nTMatrix2 : A 4D matrix of the absorption spectrum for 21->34 interaction.\n\nIf initial or final particles are identical then only one of the SMatricies or TMatricies will be returned for that state.\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.fload_Matrix_ISO-Tuple{String, String}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.fload_Matrix_ISO","text":"fload_Matrix_ISO(fileLocation,fileName)\n\nLoads just the S and T Matricies stored in fileName stored at fileLocation first converting them to an isotropic form by summing over angles. (The dimensions of the matricies stay the same i.e. 6D->6D with three dimensions having a size of 1)\n\nExample\n\n    Matricies = fload_All_ISO(fileLocation,fileName);\n\nReturns a tuple of the data stored in the file. The fields are as follows:\n\nSMatrix3 : A 6D matrix of the emission spectrum for 12->34 interaction.\nSMatrix4 : A 6D matrix of the emission spectrum for 12->43 interaction.\nTMatrix1 : A 4D matrix of the absorption spectrum for 12->34 interaction.\nTMatrix2 : A 4D matrix of the absorption spectrum for 21->34 interaction.\n\nIf initial or final particles are identical then only one of the SMatricies or TMatricies will be returned for that state.\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.fload_Matrix_Sync-Tuple{String, String}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.fload_Matrix_Sync","text":"fload_Matrix_Sync(fileLocation,fileName)\n\nLoads just the S and T Matricies stored in fileName stored at fileLocation. \n\nExample\n\n    Matricies = fload_Matrix_Sync(fileLocation,fileName);\n\nReturns a tuple of the data stored in the file. The fields are as follows:\n\nSMatrix : A 4D matrix of the emission spectrum for Synchrotron.\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.fload_Matrix_SyncISO-Tuple{String, String}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.fload_Matrix_SyncISO","text":"fload_Matrix_SyncISO(fileLocation,fileName)\n\nLoads just the S and T Matricies stored in fileName stored at fileLocation first converting them to an isotropic form by summing over angles. (The dimensions of the matricies stay the same i.e. 6D->6D with three dimensions having a size of 1)\n\nExample\n\n    Matricies = fload_Matrix_SyncISO(fileLocation,fileName);\n\nReturns a tuple of the data stored in the file. The fields are as follows:\n\nSMatrix : A 4D matrix of the emission spectrum for Synchrotron.\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.location-Tuple{Float64, Float64, Int64, Float64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.location","text":"location(u,l,num,val)\n\nReturns the index of the bin in which 'val' is contatined based on the 'num' of bins and their 'u' upper and 'l' lower bound.\n\nExamples\n\njulia> location(10e0,0e0,9,2e0)\n2\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.location_p3-Tuple{Float64, Float64, Int64, Float64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.location_p3","text":"location_p3(u,l,num,val)\n\nReturns the index of the bin in which 'val' is contatined based on the 'num' of bins and their 'u' upper and 'l' lower bound including overflow and underflow possibilities. Overflow are assigned to num+1 while underflow are assigned to lowest bin i.e. 1.\n\nExamples\n\njulia> location_p3(10e0,1e0,9,2e0)\n2\njulia> location_p3(10e0,1e0,9,11e0) # overflow\n10\njulia> location_p3(10e0,1e0,9,0.5e0) # underflow\n1\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.location_t-Tuple{Int64, Float64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.location_t","text":"location_t(numt,val)\n\nReturns the index of the bin in which the costheta 'val' is contatined based on the 'numt' of bins. Bounds [tl tu] are defined as CONST in Init.jl\n\nExamples\n\njulia> location_t(8,0.5e0)\n6\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.meanVector-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Union{Float32, Float64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.meanVector","text":"meanVector(valr)\n\nInputs a num+1 long Vector{Float} of domain bounds and returns a num long Vector{Float} of mean value in domain range.\n\nExamples\n\njulia> meanVector([1.0e0, 10.0e0, 100.0e0, 1000.0e0])\n3-element Vector{Float64}:\n 5.5\n 55.0\n 550.0\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.p4Vector!-NTuple{4, Vector{Float64}}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.p4Vector!","text":"p4Vector!(p4v,p3v,p1v,p2v)\n\nReturns the p4 vector (in standard form [p,cos(theta),phi/pi]) given the p1, p2 and p3 vectors using conservation of momentum.\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.prange-Union{Tuple{T}, Tuple{T, T, Int64}} where T<:Union{Float32, Float64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.prange","text":"prange(pl,pu,nump)\n\nReturns a nump+1 long Vector{Float} of p-space grid bounds NOT in Log10 space.\n\nExamples\n\njulia> prange(-5e0,4e0,9)\n10-element Vector{Float64}:\n 1.0e-5\n 1.0e-4\n 1.0e-3\n 0.01\n 0.1\n 1.0\n 10.0\n 100.0\n 1000.0\n 10000.0\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.sCheck-NTuple{4, Float64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.sCheck","text":"sCheck(sSmol,sBig,mu3,mu4)\n\nReturns 'true' if 's' mandelstram generated from inital system state can generate a physical output state. \n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.sigma_ElePhoElePho-Tuple{Float64, Float64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.sigma_ElePhoElePho","text":"sigma_ElePhoElePho(sSmol,sBig)\n\nreturns the total cross section for electron-photon (Compton) scattering. Berestetskii 1982 (86.16). Masses and momenta are normalised by the rest mass of the electron m_textEle and the cross section is normalised by σ_T.\n\nsigma_egammarightarrow egamma(s)=frac34(s-1)left(1-frac4left(s-1right)-frac8m_e^4left(s-1right)^2)logleft(1+fracs-11right)+frac12+frac8s-1-frac12s^2right\n\nArguments\n\nsSmol::Float64 : s - sBig\nsBig::Float64 : (m_1+m_2)^2 = 1  s = sSmol + 1\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.sigma_ElePosPhoPho-Tuple{Float64, Float64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.sigma_ElePosPhoPho","text":"sigma_ElePosPhoPho(sSmol,sBig)\n\nreturns the total cross section for electron positron annihilation to two photons. Berestetskii 1982 (88.6). Masses and momenta are normalised by the rest mass of the electron m_textEle and the cross section is normalised by σ_T.\n\nσ_e^+e^-rightarrowgammagamma = frac34s^2(s-4)left((s^2+4s-8)logleft(fracsqrts+sqrts-4sqrts-sqrts-4right)-(s+4)sqrts(s-4)right)\n\nArguments\n\nsSmol::Float64 : s - sBig\nsBig::Float64 : (m_1+m_2)^2 = 4  s = sSmol + 4\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.sigma_PhoPhoElePos-Tuple{Float64, Float64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.sigma_PhoPhoElePos","text":"sigma_PhoPhoElePos(sSmol,sBig)\n\nreturns the total cross section for photon-photon annihilation to electron-positron pair. Masses and momenta are normalised by the rest mass of the electron m_textEle and the cross section is normalised by σ_T.\n\nσ_gammagammarightarrow e^+e^- = frac32s^3left((s^2+4s-8)logleft(fracsqrt(s)+sqrt(s-4)sqrt(s)-sqrt(s-4)right)-(s+4)sqrts(s-4)right)\n\nArguments\n\nsSmol::Float64 : s - sBig\nsBig::Float64 : (m_1+m_2)^2 = 0  s = sSmol\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.sigma_SphSphSphSph-Tuple{Float64, Float64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.sigma_SphSphSphSph","text":"sigma_SphSphSphSph(sSmol,sBig)\n\nreturns the total cross section for the binary interaction of hard spheres with normalised masses (wrt electron mass) m_1m_2m_3m_4=m_textSph. Normalised by πR_Sph^2.\n\nσ = frac12\n\nArguments\n\nsSmol::Float64 : s - sBig\nsBig::Float64 : (m1+m2)^2\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.trange-Tuple{Int64}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.trange","text":"trange(numt)\n\nReturns a numt+1 long Vector{Float} of theta-space grid bounds in terms of cos(theta). Upper and lower bounds [tl tu] are defined as CONST in Init.jl as [-1 1], type returned is that of tl, tu.\n\nExamples\n\njulia> trange(8)\n9-element Vector{Float64}:\n -1.0\n -0.75\n -0.5\n -0.25\n  0.0\n  0.25\n  0.5\n  0.75\n  1.0\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BoltzmannCollisionIntegral.vectorLocation-Tuple{Float64, Float64, Int64, Int64, Vector{Float64}}","page":"Internal Functions","title":"BoltzmannCollisionIntegral.vectorLocation","text":"vectorLocation(pu,pl,nump,numt,vector)\n\nReturns a tuple of bin location for (log10momentum,cos(theta)) based on an input 'vector' and bounds 'u,l' of their domains and the 'num' of uniformly spaced bins. costheta bounds [tl tu] are defined as CONST in Init.jl\n\nExamples\n\n```julia-repl julia> vectorLocation(4e0,-5e0,9,8,[1e0,0.5e0,1.5e0]) (5,6)\n\n\n\n\n\n","category":"method"},{"location":"crosssections/#Implemented-Particles-and-Binary-Interactions","page":"Cross Sections","title":"Implemented Particles and Binary Interactions","text":"","category":"section"},{"location":"crosssections/#Particles","page":"Cross Sections","title":"Particles","text":"","category":"section"},{"location":"crosssections/","page":"Cross Sections","title":"Cross Sections","text":"Below is a table of the currently implemented particles (i.e. their particle properties are defined within the code)","category":"page"},{"location":"crosssections/","page":"Cross Sections","title":"Cross Sections","text":"Particle Abr. String Notes\nSphere \"Sph\" Mass taken to be the mass of the Proton\nElectron \"Ele\" \nPositron \"Pos\" \nProton \"Pro\" ","category":"page"},{"location":"crosssections/#Implemented-Interactions","page":"Cross Sections","title":"Implemented Interactions","text":"","category":"section"},{"location":"crosssections/","page":"Cross Sections","title":"Cross Sections","text":"These binary interactions have currently been implemented:","category":"page"},{"location":"crosssections/","page":"Cross Sections","title":"Cross Sections","text":"Collision of hard spheres SphSphSphSph\nfunctions: BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph BoltzmannCollisionIntegral.sigma_SphSphSphSph\nPhoton pair production from electron positron annihilation ElePosPhoPho\nfunctions: BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho BoltzmannCollisionIntegral.sigma_ElePosPhoPho\nElectron positron pair production from photon pair annihilation PhoPhoElePos\nfunctions: BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos BoltzmannCollisionIntegral.sigma_PhoPhoElePos\nElectron(or Positron)-Photon scattering (Compton Scattering) ElePhoElePho\nfunctions: BoltzmannCollisionIntegral.dsigmadt_ElePhoElePho BoltzmannCollisionIntegral.sigma_ElePhoElePho","category":"page"},{"location":"crosssections/#Adding-User-Defined-Interactions","page":"Cross Sections","title":"Adding User Defined Interactions","text":"","category":"section"},{"location":"crosssections/","page":"Cross Sections","title":"Cross Sections","text":"Users may add their own binary interaction cross sections to the /src/commom/DifferentialCrossSectionFunctions.jl file. Functions should be named in the following format: \"sigma_name1name2name3name4\" and \"dsigmadt_name1name2name3name4\" where the names are three letter abbreviations of the particles involved (see Particles for examples). The named pairs name1name2 and name3name4 should be in alphabetical order. Both the total cross section and differential cross sections must be provided for a single interaction.    ","category":"page"},{"location":"crosssections/","page":"Cross Sections","title":"Cross Sections","text":"All cross sections are to be defined in terms of the Mandelstram variables s=(p_1^mu+p_2^mu)^2, t=(p_1^mu-p_3^mu)^2 and u=(p_2^mu-p_3^mu)^2. To maintain accuracy of cross sections and avoid DivZero issues when momenta is small compared to the mass of the particles (at Float64 precision), each Mandelstram variable in the cross sections should be split into two components:","category":"page"},{"location":"crosssections/","page":"Cross Sections","title":"Cross Sections","text":"s=sSmol+sBig where sBig = (m_1+m_2)^2\nt=tSmol+tBig where tBig = (m_1-m_3)^2\nu=uSmol+uBig where uBig = (m_2-m_3)^2","category":"page"},{"location":"crosssections/","page":"Cross Sections","title":"Cross Sections","text":"The \"Big\" part typically cancels with terms in the cross sections, leading to better accuracy. Therefore the function should defined as follows:","category":"page"},{"location":"crosssections/","page":"Cross Sections","title":"Cross Sections","text":"function sigma_name1name2name3name4(sSmol::Float64,sBig::Float64,tSmol::Float64,tBig::Float64,uSmol::Float64,uBig::Float64)\n    ... \nend\n\nfunction dsigmadt_name1name2name3name4(sSmol::Float64,sBig::Float64,tSmol::Float64,tBig::Float64,uSmol::Float64,uBig::Float64)\n    ... \nend","category":"page"},{"location":"crosssections/","page":"Cross Sections","title":"Cross Sections","text":"where all of sSmol, sBig, tSmol, tBig, uSmol, and uBig must be included in the function definition irrespective of if they actually appear in the cross section. It is also important to define a normalisation for the cross sections to avoid emission and absorption terms becoming small compared to the Float64 minimum.","category":"page"},{"location":"crosssections/","page":"Cross Sections","title":"Cross Sections","text":"warning: Warning\nTotal cross sections may typically be defined/derived in textbooks and other sources to include division by 12 if output states are identical. This factor should NOT be included here as this factor is included separably in the code. ","category":"page"},{"location":"crosssections/#Differential-and-Total-Cross-Section-Functions","page":"Cross Sections","title":"Differential and Total Cross Section Functions","text":"","category":"section"},{"location":"crosssections/","page":"Cross Sections","title":"Cross Sections","text":"warning: Warning\nTo ensure greater computational accuracy and prevent underflow of Float64 precision values, all cross sections have a normalisation defined in the function documentation.","category":"page"},{"location":"crosssections/","page":"Cross Sections","title":"Cross Sections","text":"CurrentModule = BoltzmannCollisionIntegral\nusing BoltzmannCollisionIntegral\nend","category":"page"},{"location":"crosssections/","page":"Cross Sections","title":"Cross Sections","text":"sigma_SphSphSphSph\ndsigmadt_SphSphSphSph\n\nsigma_ElePosPhoPho\ndsigmadt_ElePosPhoPho\n\nsigma_PhoPhoElePos\ndsigmadt_PhoPhoElePos\n\nsigma_ElePhoElePho\ndsigmadt_ElePhoElePho","category":"page"},{"location":"crosssections/#BoltzmannCollisionIntegral.sigma_SphSphSphSph","page":"Cross Sections","title":"BoltzmannCollisionIntegral.sigma_SphSphSphSph","text":"sigma_SphSphSphSph(sSmol,sBig)\n\nreturns the total cross section for the binary interaction of hard spheres with normalised masses (wrt electron mass) m_1m_2m_3m_4=m_textSph. Normalised by πR_Sph^2.\n\nσ = frac12\n\nArguments\n\nsSmol::Float64 : s - sBig\nsBig::Float64 : (m1+m2)^2\n\n\n\n\n\n","category":"function"},{"location":"crosssections/#BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph","page":"Cross Sections","title":"BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph","text":"dsigmadt_SphSphSphSph(sSmol,sBig,tSmol,tBig,uSmol,uBig)\n\nreturns the differential cross section for the binary interaction of hard spheres with normalised masses m_1m_2m_3m_4=m_textSph. Normalised by πR_Sph^2.\n\nfracdσdt = frac1s-4m_textSph^2\n\nArguments\n\nsSmol::Float64 : s - sBig\nsBig::Float64 : (m_1+m_2)^2=4m_textSph^2\ntSmol::Float64 : t - tBig\ntBig::Float64 : (m_3-m_1)^2=0\nuSmol::Float64 : u - uBig\nuBig::Float64 : (m_2-m_3)^2=0\n\n\n\n\n\n","category":"function"},{"location":"crosssections/#BoltzmannCollisionIntegral.sigma_ElePosPhoPho","page":"Cross Sections","title":"BoltzmannCollisionIntegral.sigma_ElePosPhoPho","text":"sigma_ElePosPhoPho(sSmol,sBig)\n\nreturns the total cross section for electron positron annihilation to two photons. Berestetskii 1982 (88.6). Masses and momenta are normalised by the rest mass of the electron m_textEle and the cross section is normalised by σ_T.\n\nσ_e^+e^-rightarrowgammagamma = frac34s^2(s-4)left((s^2+4s-8)logleft(fracsqrts+sqrts-4sqrts-sqrts-4right)-(s+4)sqrts(s-4)right)\n\nArguments\n\nsSmol::Float64 : s - sBig\nsBig::Float64 : (m_1+m_2)^2 = 4  s = sSmol + 4\n\n\n\n\n\n","category":"function"},{"location":"crosssections/#BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho","page":"Cross Sections","title":"BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho","text":"dsigmadt_ElePosPhoPho(sSmol,sBig,tSmol,tBig,uSmol,uBig)\n\nreturns the differential cross section for electron positron annihilation to two photons. Berestetskii 1982 (88.4). Masses and momenta are normalised by the rest mass of the electron m_textEle and the cross section is normalised by σ_T.\n\nfracdσ_e^+e^-rightarrowgammagammadt = -frac3s(s-4)left(left(frac1t-1+frac1u-1right)^2+left(frac1t-1+frac1u-1right)-frac14left(fract-1u-1+fracu-1t-1right)right)\n\nArguments\n\nsSmol::Float64 : s - sBig\nsBig::Float64 : (m_1+m_2)^2 = 4  s = sSmol + 4\ntSmol::Float64 : t - tBig\ntBig::Float64 : (m_3-m_1)^2 = 1  t = tSmol + 1\nuSmol::Float64 : u - uBig\nuBig::Float64 : (m2-m3)^2 = 1  u = uSmol + 1\n\n\n\n\n\n","category":"function"},{"location":"crosssections/#BoltzmannCollisionIntegral.sigma_PhoPhoElePos","page":"Cross Sections","title":"BoltzmannCollisionIntegral.sigma_PhoPhoElePos","text":"sigma_PhoPhoElePos(sSmol,sBig)\n\nreturns the total cross section for photon-photon annihilation to electron-positron pair. Masses and momenta are normalised by the rest mass of the electron m_textEle and the cross section is normalised by σ_T.\n\nσ_gammagammarightarrow e^+e^- = frac32s^3left((s^2+4s-8)logleft(fracsqrt(s)+sqrt(s-4)sqrt(s)-sqrt(s-4)right)-(s+4)sqrts(s-4)right)\n\nArguments\n\nsSmol::Float64 : s - sBig\nsBig::Float64 : (m_1+m_2)^2 = 0  s = sSmol\n\n\n\n\n\n","category":"function"},{"location":"crosssections/#BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos","page":"Cross Sections","title":"BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos","text":"dsigmadt_PhoPhoElePos(sSmol,sBig,tSmol,tBig,uSmol,uBig)\n\nreturns the differential cross section for photon-photon annihilation to electron-positron pair. (Inverse proceess of electron positron annihilation to two photons). Masses and momenta are normalised by the rest mass of the electron m_textEle and the cross section is normalised by σ_T.\n\nfracdσ_gammagammarightarrow e^+e^-dt = -frac3s^2left(left(frac1t-1+frac1u-1right)^2+left(frac1t-1+frac1u-1right)-frac14left(fract-1u-1+fracu-1t-1right)right)\n\nArguments\n\nsSmol::Float64 : s - sBig\nsBig::Float64 : (m_1+m_2)^2 = 0  s = sSmol\ntSmol::Float64 : t - tBig\ntBig::Float64 : (m_3-m_1)^2 = 1  t = tSmol + 1\nuSmol::Float64 : u - uBig\nuBig::Float64 : (m_2-m_3)^2 = 1  u = uSmol + 1\n\n\n\n\n\n","category":"function"},{"location":"crosssections/#BoltzmannCollisionIntegral.sigma_ElePhoElePho","page":"Cross Sections","title":"BoltzmannCollisionIntegral.sigma_ElePhoElePho","text":"sigma_ElePhoElePho(sSmol,sBig)\n\nreturns the total cross section for electron-photon (Compton) scattering. Berestetskii 1982 (86.16). Masses and momenta are normalised by the rest mass of the electron m_textEle and the cross section is normalised by σ_T.\n\nsigma_egammarightarrow egamma(s)=frac34(s-1)left(1-frac4left(s-1right)-frac8m_e^4left(s-1right)^2)logleft(1+fracs-11right)+frac12+frac8s-1-frac12s^2right\n\nArguments\n\nsSmol::Float64 : s - sBig\nsBig::Float64 : (m_1+m_2)^2 = 1  s = sSmol + 1\n\n\n\n\n\n","category":"function"},{"location":"crosssections/#BoltzmannCollisionIntegral.dsigmadt_ElePhoElePho","page":"Cross Sections","title":"BoltzmannCollisionIntegral.dsigmadt_ElePhoElePho","text":"dsigmadt_ElePhoElePho(sSmol,sBig,tSmol,tBig,uSmol,uBig)\n\nreturns the differential cross section for electron-photon scattering (Compton) scattering. Berestetskii 1982 (86.6). Masses and momenta are normalised by the rest mass of the electron m_textEle and the cross section is normalised by σ_T.\n\nfracdsigma_egammarightarrow egammadt(st)=frac3(s-1)^2leftleft(frac1s-1+frac1u-1right)^2+left(frac1s-1+frac1u-1right)-frac14left(fracs-1u-1+fracu-1s-1right)right\n\nArguments\n\nsSmol::Float64 : s - sBig\nsBig::Float64 : (m_1+m_2)^2 = 1  s = sSmol + 1\ntSmol::Float64 : t - tBig\ntBig::Float64 : (m_3-m_1)^2 = 0  t = tSmol\nuSmol::Float64 : u - uBig\nuBig::Float64 : (m_2-m_3)^2 = 1  u = uSmol + 1\n\n\n\n\n\n","category":"function"},{"location":"quickstart/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"quickstart/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"BoltzmannCollisionIntegral.jl is available to download from the Julia package manager. Inside a Julia session, enter the package manager with ], then run the command","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"pkg> add BoltzmannCollisionIntegral","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"finally load the package by running","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"using BoltzmannCollisionIntegral","category":"page"},{"location":"quickstart/#Integrating","page":"Getting Started","title":"Integrating","text":"","category":"section"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"BoltzmannCollisionIntegral.jl contains the following modules:","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Binary Interactions 12->34\nSynchrotron emission    ","category":"page"},{"location":"quickstart/#Quick-Start-for-Binary-Interactions-Module","page":"Getting Started","title":"Quick Start for Binary Interactions Module","text":"","category":"section"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"note: Note\nAn example script Run_Integration.jl for setting up and running the evaluation of the discrete binary collision integral can be found under src/Common/ of the package. It is recommended that you copy this script to your working directory, edit the relevant fields and then running, either using the command include(\"Run_Integration.jl)in a julia-repl session, or by running the script line by line in your favourite code editor.","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"The example script Run_Integration.jl operates as follows:","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Define the names of the 4 particles involved in the interaction (12to34) as the strings name1 name2 name3 name4\nThese should of the form of three letters, which abbreviate the particles full name (see Particles for list of currently implemented particles).\nThey should be ordered to match a currently Implemented Interactions\nDefine the momentum space discretisation. This includes the upper and lower bounds of momentum (log10) for particle species 1,2 and 3 (e.g. p1l and p1u for species 1) and the number of divisions (bins) for each particles momentum space (e.g. nump1).\nDefine the number of divisions for the angular momentum space (i.e. cos(theta) space) for the particle species 1,2 and 3 (e.g. numt1). \nDefine the number of Monte-Carlo samples to perform (as a rule of thumb, on a modern CPU it takes approximately 200ns per sample).\nnumTiter for the number of random sets of vecp_1vecp_2 to sample. \nnumSiter for the number of random vecp_3 states to sample per vecp_1vecp_2.\nIf multithreading then define nThreads that will be used. This generates nThreads workers that perform evaluation in parallel, utilising locks to prevent data races. (see Multi-Threading for how to set up multi-threading in Julia)\nDefine the fileLocation where the output file (JLD2) named fileName is to be written.\nEvaluate the emission and absorption spectrum using the SpectraEvaluateSerial function for serial and SpectraEvaluateMultiThread for multithread. Once run, these functions will save the results to the output file.","category":"page"},{"location":"quickstart/#Quick-Start-for-Synchrotron-Module","page":"Getting Started","title":"Quick Start for Synchrotron Module","text":"","category":"section"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"note: Note\nAn example script Run_Integration_Sync.jl for setting up and running the evaluation of the discrete binary collision integral can be found under src/Synchrotron/Common/ of the package. It is recommended that you copy this script to your working directory, edit the relevant fields and then running, either using the command include(\"Run_Integration_Sync.jl)in a julia-repl session, or by running the script line by line in your favourite code editor.","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"The example script Run_Integration_Sync.jl operates as follows:","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Define the name of the emitting particle as the strings name2\nThis should of the form of three letters, which abbreviate the particles full name (see Particles for list of currently implemented particles).\nDefine the momentum space discretisation. This includes the upper and lower bounds of momentum (log10) for the emitted photons (species 1) and emitting particle (species 2) i.e. p1l and p1u for species 1, and the number of divisions (bins) for each particles momentum space, i.e. nump1.\nDefine the number of divisions for the angular momentum space (i.e. cos(theta) space) for the particle species 1 and 2 (i.e. numt1). \nDefine the number of Monte-Carlo samples to perform (as a rule of thumb, on a modern CPU it takes approximately 200ns per sample).\nnumTiter for the number of random sets of vecp_2 to sample, i.e. emitting particle states. \nnumSiter for the number of random vecp_2 states to sample per vecp_2, i.e. number of emitted photons to sample per emitting particle state.\nIf multithreading then define nThreads that will be used. This generates nThreads workers that perform evaluation in parallel, utilising locks to prevent data races. (see Multi-Threading for how to set up multi-threading in Julia)\nDefine the fileLocation where the output file (JLD2) named fileName is to be written.\nEvaluate the emission and absorption spectrum using the SyncEvaluateSerial function for serial and SyncEvaluateMultiThread for multithread. Once run, these functions will save the results to the output file.","category":"page"},{"location":"quickstart/#Output-Files","page":"Getting Started","title":"Output Files","text":"","category":"section"},{"location":"quickstart/#Output-for-Binary-Interactions","page":"Getting Started","title":"Output for Binary Interactions","text":"","category":"section"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"The data stored in an output file can be loaded back into the workspace as a tuple using the fload_All function.","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"    (Run_Parameters,SAtot3,SAtot4,TAtot,SAtal3,SAtal4,TAtal,SMatrix3,SMatrix4,TMatrix1,TMatrix2,p3Max,p4Max,t3MinMax,t4MinMax,SConv3,SConv4,TConv) = fload_All(fileLocation,fileName)","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"This returns a Tuple containing various arrays:","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Run_Parameters : A tuple of the parameters used in the evaluation.\nStot3 : A 6D matrix totalling all the emission spectrum values sampled for 12to34 interaction.\nStot4 : A 6D matrix totalling all the emission spectrum values sampled for 12to43 interaction.\nTtot : A 4D matrix totalling all the absorption spectrum values sampled.\nStal3 : A 5D matrix of tallies of the number of emission spectrum values sampled for 12->34 interaction.\nStal4 : A 5D matrix of tallies of the number of emission spectrum values sampled for 12->43 interaction.\nTtal : A 4D matrix of tallies of the number of absorption spectrum values sampled.\nSMatrix3 : A 6D matrix of the emission spectrum for 12to34 interaction.\nSMatrix4 : A 6D matrix of the emission spectrum for 12to43 interaction.\nTMatrix1 : A 4D matrix of the absorption spectrum for 12to34 interaction.\nTMatrix2 : A 4D matrix of the absorption spectrum for 21to34 interaction i.e. by permutation of TMatrix1 and correct application of phase space factors if species 1 != species 2.\np3Max : The maximum value of the momentum space variable p3 sampled for each bin. (Useful for correcting numerical diffusion)\nt3MinMax : The minimum and maximum values of the momentum space variable t3 sampled for each bin. (Useful for correcting numerical diffusion)\np4Max : The maximum value of the momentum space variable p4 sampled for each bin. (Useful for correcting numerical diffusion)\nt4MinMax : The minimum and maximum values of the momentum space variable t4 sampled for each bin. (Useful for correcting numerical diffusion)\nSConv3 : A 6D matrix of the convergence of the emission spectrum compared to the previous run with given Run_Parameters for 12to34 interaction.\nSConv4 : A 6D matrix of the convergence of the emission spectrum compared to the previous run with given Run_Parameters for 12to43 interaction.\nTConv : A 4D matrix of the convergence of the absorption spectrum compared to the previous run with given Run_Parameters.","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Conservation of particle number and energy can be checked using the DoesConserve function.","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"The key statistic is ratioN and ratioE which dictate the ratio of particle number and energy before and after the interaction and should be close to 1.","category":"page"},{"location":"quickstart/#Output-for-Synchrotron","page":"Getting Started","title":"Output for Synchrotron","text":"","category":"section"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"The data stored in an output file can be loaded back into the workspace as a tuple using the fload_All_Sync function.","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"    (Run_Parameters,SAtot,SAtal,SMatrix,#=pMax,tMinMax,=#,SConv) = fload_All_Sync(fileLocation,fileName)","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Returns a tuple of the data stored in the file. The fields are as follows:","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Run_Parameters : A tuple of the parameters used in the evaluation.\nStot : A 4D matrix totalling all the synchrotron emission spectrum values\nStal : A 4D matrix of tallies of the number of synchrotron emission spectrum values sampled\nSMatrix : A 4D matrix of the synchrotron emission spectrum.\npMax : The maximum value of the momentum space variable p1 (photon mommentum) sampled for each bin. (Useful for correcting numerical diffusion)\ntMinMax : The minimum and maximum values of the momentum space variable t1 sampled for each bin. (Useful for correcting numerical diffusion)\nSConv : A 4D matrix of the convergence of the synchrotron emission spectrum compared to the previous run with given Run_Parameters.","category":"page"},{"location":"synchrotron/#Synchrotron-Radiation","page":"Synchrotron Emissions","title":"Synchrotron Radiation","text":"","category":"section"},{"location":"synchrotron/","page":"Synchrotron Emissions","title":"Synchrotron Emissions","text":"The synchrotron module allows for the evaluation of the rate of change of photon population (partial_t f(p_1costheta_1)) due to synchrotron emissions from a distribution (f(p_2costheta_2)) charged particles, with mass m_2 and charge q_2, in a uniform magnetic field of strength B aligned with the axis of symmetry.","category":"page"},{"location":"synchrotron/","page":"Synchrotron Emissions","title":"Synchrotron Emissions","text":"The rate of change of photon distribution function is given by:","category":"page"},{"location":"synchrotron/","page":"Synchrotron Emissions","title":"Synchrotron Emissions","text":"left(fracpartial f(boldsymbolp_1)partial tright)_Sync=fracZmu^2Bfrac3c^5sigma_Tm_e^54pihbar^3mu_0e^3intmathrmd^3boldsymbolp_2frac1p_1p^0_2leftleft(fracp^0_2costheta_1-p_2costheta_2costheta_1sintheta_1right)^2J_omegaomega_0(x)^2+(p_2sintheta_2)^2 J_omegaomega_0(x)^2rightf(boldsymbolp_2)","category":"page"},{"location":"synchrotron/","page":"Synchrotron Emissions","title":"Synchrotron Emissions","text":"where J are the Bessel functions (J refer to the derivative with respect to the argument), fracomegaomega_0=fracm_e^2c^2p_1Zhbar eBleft(p^0_2-p_1costheta_1costheta_2right) and x=fracomegaomega_0=fracm_e^2c^2p_1Zhbar eBp_1p_2sintheta_1sintheta_2. Z and mu are the normalised charge and mass of the emitting particle, normalised by the fundamental charge and electron mass respectively, all other constants have their standard (SI) values.","category":"page"},{"location":"synchrotron/","page":"Synchrotron Emissions","title":"Synchrotron Emissions","text":"Making the standard set of assumptions laid out in BoltzmannCollisionIntegral.jl this can be re-written in the form","category":"page"},{"location":"synchrotron/","page":"Synchrotron Emissions","title":"Synchrotron Emissions","text":"left(fracpartial f_1ijpartial tright)_sync=S_ijklf_2kl","category":"page"},{"location":"synchrotron/","page":"Synchrotron Emissions","title":"Synchrotron Emissions","text":"with ","category":"page"},{"location":"synchrotron/","page":"Synchrotron Emissions","title":"Synchrotron Emissions","text":"S_ijkl=frac2piDelta p_iDelta u_jint_Delta p_iDelta u_jp_1^2mathrmdp_1mathrmdu_1 int mathrmdp_2mathrmdu_2leftfracZmu^2Bfrac3c^5sigma_Tm_e^54pihbar^3mu_0e^3rightfrac1p_1p^0_2leftleft(fracp^0_2 u_1-p_2u_2u_1sqrt1-u^2_1right)^2J_omegaomega_0(x)^2+p_1^2(1-u_2^2) J_omegaomega_0(x)^2right","category":"page"},{"location":"synchrotron/","page":"Synchrotron Emissions","title":"Synchrotron Emissions","text":"where u=costheta.","category":"page"},{"location":"synchrotron/","page":"Synchrotron Emissions","title":"Synchrotron Emissions","text":"note: Note\nEvaluation is normalised by csigma_T to match the normalisation of the binary collision integral.","category":"page"},{"location":"synchrotron/","page":"Synchrotron Emissions","title":"Synchrotron Emissions","text":"The values of S_ijkl are then evaluated using a Monte Carlo method. To improve accuracy when omegaomega_0ge 10^3, the following approximation of the Bessel functions are made: ","category":"page"},{"location":"synchrotron/","page":"Synchrotron Emissions","title":"Synchrotron Emissions","text":"J_n(x)approxfrac1pisqrt3left(1-fracx^2n^2right)^12K_13left(fracn3left(1-fracx^2n^2right)^32right)","category":"page"},{"location":"synchrotron/","page":"Synchrotron Emissions","title":"Synchrotron Emissions","text":"J_n(x)approxfrac1pisqrt3left(1-fracx^2n^2right)K_23left(fracn3left(1-fracx^2n^2right)^32right)","category":"page"},{"location":"#BoltzmannCollisionIntegral.jl","page":"Overview","title":"BoltzmannCollisionIntegral.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"BoltzmannCollisionIntegral.jl is a package for the evaluation of the Boltzmann collision integral for binary interactions of arbitrary momentum and anisotropic particle distributions using a method of momentum discretisation and Monte-Carlo integration. ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The code now also includes a module for the evaluation of synchrotron emissions, with details found in Synchrotron Radiation.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The evaluation of the collision integral is of great use when studying kinetic system. The evolution of particle distributions f(x^muboldsymbolp) within such a system is dictated by the collisional relativistic Boltzmann equation (Everett+Cotter 2024):","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"p^nupartial_nu f(x^muboldsymbolp)+partial_p^nuleft(F^nu f(x^muboldsymbolp)right)=C(x^muboldsymbolp)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"where p^mu=(p^0boldsymbolp) is the 4-Momentum and C(x^muboldsymbolp) is the collision integral at a particular point in spacetime x^mu. From here we shall neglect the terms involving advection in space and advection on momentum-space (external forcing), as such the dependence on x^mu is also dropped. What is left can be written as ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"    partial_t f(boldsymbolp) = frac1p^0C(boldsymbolp)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The collision integral for a particular particle 3 in the interaction 12rightleftharpoons34 is given by ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"    C(boldsymbolp_3)=intfracmathrmd^3boldsymbolp_1p_1^0fracmathrmd^3boldsymbolp_2p_2^0fracmathrmd^3boldsymbolp_4p_4^0leftfracf(boldsymbolp_1)f(boldsymbolp_2)1+delta_12W(p_1^mup_2^mup_3^mup_4^mu)- fracf(boldsymbolp_3)f(boldsymbolp_4)1+delta_12W(p_3^mup_4^mup_1^mup_2^mu)right","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"with the transition rate W being given by:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"W(p_1^mup_2^mup_3^mup_4^mu)=fracsp_textin^*2pifracmathrmdsigma_1234mathrmdt(st)delta^(4)(p_1^mu+p_2^mu-p_3^mu-p_4^mu)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"and fracmathrmdsigma_1234mathrmdt(st) is the Lorentz invariant differential cross section of the forward reaction 12to34.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The Boltzmann equation can then be discretised in momentum space by integrating over a discrete volume element Delta^3boldsymbolp_3 to yield: ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"int_Delta^3boldsymbolp_3fracmathrmd^3boldsymbolp_3p_3^0p_3^mupartial_mu f(x^muboldsymbolp_3)=int_Delta^3boldsymbolp_3mathrmd^3boldsymbolp_3S_spe(x^muboldsymbolp_3)-T_spe(x^muboldsymbolp_3)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"where the collision integral has been split into two parts, an emission spectrum","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"S_textspe(boldsymbolp_3)=frac11+delta_12frac1p^0_3intfracmathrmd^3boldsymbolp_1p_1^0fracmathrmd^3boldsymbolp_2p_2^0fracmathrmd^3boldsymbolp_4p_4^0f(boldsymbolp_1)f(boldsymbolp_2)W(p_1^mup_2^mup_3^mup_4^mu)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"math dictating the rate of gain of particles of a specific type at a specific momentum from a binary interaction, and an absorption spectrum ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"T_textspe(boldsymbolp_3)=frac11+delta_12frac1p^0_3intfracmathrmd^3boldsymbolp_1p_1^0fracmathrmd^3boldsymbolp_2p_2^0fracmathrmd^3boldsymbolp_4p_4^0 f(boldsymbolp_3)f(boldsymbolp_4)W(p_3^mup_4^mup_1^mup_2^mu)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"dictating the rate of loss of particles of a specific type at a specific momentum from the same interaction.","category":"page"},{"location":"#Assumptions","page":"Overview","title":"Assumptions","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"In order to enable the evaluation of the emission and absorption terms, we make the following set of assumptions (dropping dependence on space-time for notational simplicity):  ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The system is axisymmetric in momentum space coordinates i.e. only dependant on p=boldsymbolp and the cosine of the angle to the axis of symmetry (hatz) u where hatzcdotboldsymbolp=pcostheta=pu \nThe distribution functions are redefined in an axisymmetric form i.e. f(boldsymbolp)equivfracf(pu)2pi p^2. This is done such that a single particle is described by the distribution f(pu)=delta(p-p_i)delta(u-u_i).\nThe axisymmetric distribution functions are averaged over phase space intervals Delta pDelta u, to generate discrete values i.e. f(tp_i u_j)=frac1Delta p_iDelta u_jint_Delta p_iDelta u_j mathrmdp mathrmd uf(p u), such that they act as if they are constant over that interval of phase space.  \nParticle masses, momenta and energies are normalised by a factor of the rest mass of the electron m_textEle and the speed of light c=1.","category":"page"},{"location":"#Discrete-Form-of-the-Boltzmann-Equation","page":"Overview","title":"Discrete Form of the Boltzmann Equation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Following the assumptions laid out in the previous section. The axisymmetric, momentum-discrete Boltzmann equation is given by (remember the neglect of space and momentum-space advection terms)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"partial_t f_3ij=f_1klf_2mnS_1234ijklmn-f_3ijf_4klT_3412ijkl","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The discrete emission spectrum term is a 6D array, given by","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"f_1klf_2mnS_1234ijklmn=f(p_1k u_1l)f(p_2m u_2n)fracDelta p_1kDelta  u_1lDelta p_2mDelta  u_2nDelta p_3ifrac1Nsum^N_a=1leftS_valright(boldsymbolp_1boldsymbolp_2boldsymbolp_3_a) ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"with ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"S_val=frac11+delta_12sum_pmfrac2p_pm^2mathcalF_12^2p_1^0p_2^0fracmathrmdsigma_1234mathrmdt(st_pm)frac1p_1^0p_pm-p_pm^0p_1cosTheta_pm1+p_2^0p_pm-p_pm^0p_2cosTheta_pm2","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"where p_pm are the two roots of (s+t-m_3^2-m_2^2-2p^ u_1p_4 u). ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The discrete absorption term is a 4D Array, given by","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"f_3ijf_4klT_3412ijkl=f(p_3i u_3j)f(p_4k u_4l)Deltaboldsymbolp_4kDelta u_4lfrac1Nsum^N_a=1leftT_valright(boldsymbolp_3boldsymbolp_4_a)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"with","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"T_val=frac11+delta_12fracmathcalF_34(s)sigma_3412(s)p_3^0p_4^0","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"and sigma_3412(s) the lorentz invariant total cross section of the reverse reaction 34to12.","category":"page"},{"location":"#Evaluation","page":"Overview","title":"Evaluation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Given a user input of interaction to evaluate and what discretisation to use, the discrete emission spectra S_1234ijklmn, S_1243ijklmn and absorption spectra T_1234ijkl, T_2134ijkl are solved simultaneously by Monte-Carlo integration. This provides all matricies required to self consistently model the evolution of particles due to the forward interaction 12to34. ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"note: Note\nThe order of the interaction in the absorption spectrum (3412 to 1234) is changed for easier evaluation as sampled points can be used for both emission and absorption terms. Rather than solving for the forward and reverse reaction, only the forward reaction is solved for. Hence two sets of emission and absorption spectra are need to be generated in general to describe a single reversible reaction.  ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The evaluation is performed by the functions SpectraEvaluateSerial or SpectraEvaluateMultiThread depending on if the code is to run in serially on a single core or multi-threaded on multiple cores of a single CPU. The code will then save the resulting multidimensional arrays.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"warning: Warning\nThe evaluation does not guarantee convergence of the Monte-Carlo integration, instead it will sample only a user defined number of points. A rough measure of convergence is calculated (based on comparison to the output of the previous run) and stored as SConverge and TConverge in the output file.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Evaluation is performed using Float64 precision, with all Internal Functions designed to maintain accuracy to this precision.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"An in-depth setup guide is provided in the Getting Started section.  ","category":"page"}]
}
