var documenterSearchIndex = {"docs":
[{"location":"internalfunctions/#Internal-functions","page":"Internal Functions","title":"Internal functions","text":"","category":"section"},{"location":"internalfunctions/","page":"Internal Functions","title":"Internal Functions","text":"CurrentModule = BinaryInteractionSpectra\nusing BinaryInteractionSpectra\nend","category":"page"},{"location":"internalfunctions/","page":"Internal Functions","title":"Internal Functions","text":"Modules = [BinaryInteractionSpectra]","category":"page"},{"location":"internalfunctions/#BinaryInteractionSpectra.InvarientFlux-Tuple{Float32, Float32, Float32}","page":"Internal Functions","title":"BinaryInteractionSpectra.InvarientFlux","text":"InvarientFlux(s,mass12,mass22)\n\nreturns the value of the invarient flux with 's' mandelstram variable and masses 'mass1' and 'mass2'\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.InvarientFlux2-Tuple{Float32, Float32, Float32}","page":"Internal Functions","title":"BinaryInteractionSpectra.InvarientFlux2","text":"InvarientFlux2(s,mass12,mass22)\n\nreturns the value of the squared invarient flux with 's' mandelstram variable and masses 'mass1' and 'mass2'\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.InvarientFlux2Small-Tuple{Float32, Float32, Float32}","page":"Internal Functions","title":"BinaryInteractionSpectra.InvarientFlux2Small","text":"InvarientFluxSmall(sSmol,mass12,mass22)\n\nreturns the value of the squared invarient flux with smalled 's' mandelstram variable (sSmol = s - (m1+m2)^2)\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.InvarientFluxSmall-Tuple{Float32, Float32, Float32}","page":"Internal Functions","title":"BinaryInteractionSpectra.InvarientFluxSmall","text":"InvarientFluxSmall(sSmol,mass12,mass22)\n\nreturns the value of the invarient flux with smalled 's' mandelstram variable (sSmol = s - (m1+m2)^2)\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.Momentum3Value!-NTuple{4, Vector{Float32}}","page":"Internal Functions","title":"BinaryInteractionSpectra.Momentum3Value!","text":"Momentum3Value!(p3v,p3pv,p1v,p2v)\n\nTakes set of random initial particle states 'p1v' and 'p2v' and random output states angles 'p3v[2:3]' and modifies outputs 'p3v' and 'p3pv' values with calculated output momentum and corrects angles if momentum is negative. Function also returns a two bools 'p3physical' and 'p3pphysical' indicating if p3 and p3p are physical momentum states given the inputs.  Function also returns a Int 'NumStates' indicating the number of valid output states found.\n\nRequrires normalised masses (mu1,mu2,mu3,mu4) to be defined in advance in Init.jl as const.\n\nExamples\n\njulia> mu1 = 1836.1528f0\njulia> mu2 = 1836.1528f0\njulia> mu3 = 1836.1528f0\njulia> mu4 = 1836.1528f0\njulia> p1v = [1f0, 0.5f0, 1.8f0]\njulia> p2v = [2f0, 0.2f0, 0.7f0]\njulia> p3v = [0f0, 0.3f0, 0.7f0]\njulia> p3pv = zeros(Float32,3)\njulia> p3pv .= p3v\njulia> Momentum3Value!(p3v,p3pv,p1v,p2v)\n(true,true,2)\njulia> p3v\n 3-element Vector{Float32}:\n 2.04505\n 0.3\n 0.7\njulia> p3pv\n 3-element Vector{Float32}\n 0.691423\n -0.3\n 1.7\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.PhaseSpaceFactors1!-Tuple{Array{Float32, 6}, Array{Float32, 4}, Vararg{Vector{Float32}, 5}}","page":"Internal Functions","title":"BinaryInteractionSpectra.PhaseSpaceFactors1!","text":"PhaseSpaceFactors1!(SMatrix,TMatrix,t3val,p1val,t1val,p2val,t2val)\n\nApplies phase space volume element factors for 'SMatrix' and 'TMatrix' terms in order to correctly apply 'STSymmetry' corrections. \n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.PhaseSpaceFactors2!-Tuple{Array{Float32, 6}, Array{Float32, 4}, Vararg{Vector{Float32}, 4}}","page":"Internal Functions","title":"BinaryInteractionSpectra.PhaseSpaceFactors2!","text":"PhaseSpaceFactors2!(SMatrix,TMatrix,t3val,p1val,t1val,p2val,t2val)\n\nTo follow 'PhaseSpaceFactors1' and 'STSymmetry'. Corrects phase space factors on 'SMatrix' and 'TMatrix' for use in kinetic codes. Assumes f(x,p,μ)= constant\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.RPointLogMomentum!-Tuple{Float32, Float32, Vector{Float32}, Int64}","page":"Internal Functions","title":"BinaryInteractionSpectra.RPointLogMomentum!","text":"RPointLogMomentum!(pu,pl,pv,num)\n\nEdits the first element of 'pv' with a random real-space momentum value between 10^pl and 10^pu. This sample is chosen by first randomly picking a momentum bin in the range 1:num and then uniformly sampling a momentum point in real-space (rather than log10 space) between l and u which are the momentum values at start and end of that bin. Sampling is done such there will be a constant number of points per momentum-space volume. As the momentum space between 10^pl and 10^pu it is a spherical shell hence the correct sampling is p = (U(10^pu)^3+(1-U)(10^pl)^3)^1/3 with uniform U ∈ [0 1].\n\nAssumes f(xpμ)=f(xvecp)*(2pi p^2)=const in bin, therefore momentum space volume element is dp and as such uniform sampling corresponds to U*10^(u)+(1-U)*10^(l) where U is a uniform random number between 0 and 1.\n\nIf instead f(xvecp)=const in bin, momentum space volume element is p^2 dp and uniform sampling corresponds to (10^u)*cbrt(U+(1-U)*10^(3l-3u)) where U is a uniform random number between 0 and 1.\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.RPointSphereCosThetaPhi!-Tuple{Vector{Float32}}","page":"Internal Functions","title":"BinaryInteractionSpectra.RPointSphereCosThetaPhi!","text":"RPointSphereThetaPhi!()\n\nAssigns the second (cos(theta)) and third (phi) elements of 'a' with a randomly, uniformly sampled values of spherical angles cos(theta) and phi (phi normalised by pi). \n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.STMonteCarloAxi_MultiThread!-Tuple{Array{Float32, 6}, Array{Float32, 4}, Array{UInt32, 5}, Array{UInt32, 4}, Any, Array{Float32, 5}, Array{Float32, 6}, Function, Function}","page":"Internal Functions","title":"BinaryInteractionSpectra.STMonteCarloAxi_MultiThread!","text":"STMonteCarloAxi_MultiThread!(SAtotal,TAtotal,SAtally,TAtally,p3v,p3pv,p1v,p2v,p3Max,t3MinMax})\n\nArguments\n\nSAtotal::Array{Float32,6} : Array of stored integration totals for S matrix\nTAtotal::Array{Float32,4} : Array of stored integration totals for T matrix\nSAtally::Array{UInt32,5} : Array of stored integration tallies for S matrix\nTAtally::Array{UInt32,4} : Array of stored integration tallies for T matrix\np3v::Vector{Float32} : Vector of momentum values for species 3\np3pv::Vector{Float32} : Second Vector of momentum values for species 3 for when two states are possible\np1v::Vector{Float32} : Vector of momentum values for species 1\np2v::Vector{Float32} : Vector of momentum values for species 2\np3Max::Array{Float32,5} : Array of maximum momentum values for species 3\nt3MinMax::Array{Float32,6} : Array of minimum and maximum theta values for species 3\n\nOutput:\n\nArgument arrays SAtotal,TAtotal,SAtally,TAtally are mutated to include the results of the Monte Carlo Integration.\n\nHidden Inputs (defined in Init.jl)\n\nDomain Boundaries (defined as CONST)       - p bounds and divisions for species 1,3,4       - theta divisions for species 1,3,4 ( bounds not needed as assumed [-1,1] )       - phi divisions for species 1,3,4 ( bounds not needed as assumed [0,2] )\nParticle Masses (defined as CONST)\nnumTiterPerThread and numSiterPerThread as the number of T and S integrations to perform.\n\nCalculation In Breif\n\nSet up worker threads\nRandom Sample points in each of these domains\nRandomPointSphere for theta and phi (for species 1,2,3)\nRandomPointMomentum for p ( species 1,2 only )\nTake random points (t3,h1,p1,p2,t1,t2,h3,h4) and calculate valid p3 point/points \nFind position in local S and T arrays and allocated tallies and totals accordingly.\nUpdate global S and T arrays with locks to prevent data races\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.STMonteCarloAxi_Serial!-Tuple{Array{Float32, 6}, Array{Float32, 4}, Array{UInt32, 5}, Array{UInt32, 4}, Vector{Float32}, Vector{Float32}, Vector{Float32}, Vector{Float32}, Array{Float32, 5}, Array{Float32, 6}, Function, Function}","page":"Internal Functions","title":"BinaryInteractionSpectra.STMonteCarloAxi_Serial!","text":"STMonteCarloAxi_Serial!(SAtotal,TAtotal,SAtally,TAtally,p3v,p3pv,p1v,p2v,p3Max,t3MinMax})\n\nArguments\n\nSAtotal::Array{Float32,6} : Array of stored integration totals for S matrix\nTAtotal::Array{Float32,4} : Array of stored integration totals for T matrix\nSAtally::Array{UInt32,5} : Array of stored integration tallies for S matrix\nTAtally::Array{UInt32,4} : Array of stored integration tallies for T matrix\np3v::Vector{Float32} : Vector of momentum values for species 3\np3pv::Vector{Float32} : Second Vector of momentum values for species 3 for when two states are possible\np1v::Vector{Float32} : Vector of momentum values for species 1\np2v::Vector{Float32} : Vector of momentum values for species 2\np3Max::Array{Float32,5} : Array of maximum momentum values for species 3\nt3MinMax::Array{Float32,6} : Array of minimum and maximum theta values for species 3\n\nOutput:\n\nArgument arrays SAtotal,TAtotal,SAtally,TAtally are mutated to include the results of the Monte Carlo Integration.\n\nHidden Inputs (defined in Init.jl)\n\nDomain Boundaries (defined as CONST)       - p bounds and divisions for species 1,3,4       - theta divisions for species 1,3,4 ( bounds not needed as assumed [-1,1] )       - phi divisions for species 1,3,4 ( bounds not needed as assumed [0,2] )\nParticle Masses (defined as CONST)\nnumTiter and numSiter as the number of T and S integrations to perform.\n\nCalculation In Breif\n\nRandom Sample points in each of these domains\nRandomPointSphere for theta and phi (for species 1,2,3)\nRandomPointMomentum for p ( species 1,2 only )\nTake random points (t3,h1,p1,p2,t1,t2,h3,h4) and calculate valid p3 point/points \nFind position in S and T arrays and allocated tallies and totals accordingly.\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.STSymmetry!-Tuple{Array{Float32, 6}, Array{Float32, 4}}","page":"Internal Functions","title":"BinaryInteractionSpectra.STSymmetry!","text":"STSymmetry!(SMatrix,TMatrix,t3val,p1val,t1val,p2val,t2val)\n\nTo follow 'PhaseSpaceFactors1'. Physical nature of binary interaction has certain symmetries. 'STSymmetry' uses these symmetries to improve MC sampling of 'SMatrix' and 'TMatrix'.\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.SValue-Tuple{Vector{Float32}, Vector{Float32}, Vector{Float32}, Function}","page":"Internal Functions","title":"BinaryInteractionSpectra.SValue","text":"SValue(p3v,p1v,p2v,dsigmadt)\n\nReturns Sval from MC integration based on initial momentum states p1v and p2v and final state p3v and differential cross section dsigmadt based on particle selection.   Assumes f(x,p,μ)=constant over bin\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.SpectraEvaluateMultiThread-Tuple{}","page":"Internal Functions","title":"BinaryInteractionSpectra.SpectraEvaluateMultiThread","text":"SpectraEvaluateMultiThread()\n\nFunction to run the Monte Carlo integration of the S and T arrays in a multi-threaded environment. The function will run the Monte Carlo integration in parallel across the number of threads specified in the global variable nThreads. The function will then calculate the S and T matricies and save the results to a file.\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.SpectraEvaluateSerial-Tuple{}","page":"Internal Functions","title":"BinaryInteractionSpectra.SpectraEvaluateSerial","text":"SpectraEvaluateSerial()\n\nFunction to run the Monte Carlo integration of the S and T arrays in a serial environment. The function will run the Monte Carlo integration in serial and then calculate the S and T matricies and save the results to a file.\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.TValue-Tuple{Vector{Float32}, Vector{Float32}, Function}","page":"Internal Functions","title":"BinaryInteractionSpectra.TValue","text":"TValue(p1v,p2v,sigma)\n\nreturns Tval with its Tval from MC integration based on initial momentum states p1v and p2v and cross section sigma based on particle selection. If initial state fails sCheck, i.e. cannot generate a physical output state, Tval is set to 0f0.  Assumes f(x,p,μ)=constant over bin\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.deltaEVector-Tuple{Vector{Float32}, Float32}","page":"Internal Functions","title":"BinaryInteractionSpectra.deltaEVector","text":"deltaEVector(pr,mu)\n\nInputs a (num+1) vector{Float32} of p grid boundries and the particle mu value and returns a (num) vector{Float32} of average energy values per grid cell.\n\nExamples\n\njulia> deltaEVector([1.0f0, 10.0f0, 100.0f0, 1000.0f0], 1.0f0)\n3-element Vector{Float32}:\n 50.600693\n 4951.15\n 495001.16\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.deltaVector-Tuple{Vector{Float32}}","page":"Internal Functions","title":"BinaryInteractionSpectra.deltaVector","text":"deltaVector(valr)\n\nInputs a (num+1) vector{Float32} quantitiy values (domain bounds) and returns a (num) vector{Float32} of differeces (domain widths).\n\nExamples\n\njulia> deltaVector([1.0f0, 10.0f0, 100.0f0, 1000.0f0])\n3-element Vector{Float32}:\n 9.0\n 90.0\n 900.0\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.dsigmadt_ElePosPhoPho-NTuple{6, Float32}","page":"Internal Functions","title":"BinaryInteractionSpectra.dsigmadt_ElePosPhoPho","text":"dsigmadt_ElePosPhoPho(sSmol,sBig,tSmol,tBig,uSmol,uBig)\n\nreturns the differential cross section for electron positron annihilation to two photons. Berestetskii 1982 (88.4)\n\nArguments\n\nsSmol::Float32 : s - sBig\nsBig::Float32 : (m1+m2)^2 = 4 (normalised units) -> s = sSmol + 4\ntSmol::Float32 : t - tBig\ntBig::Float32 : (m3-m1)^2 = 1 (normalised units) -> t = tSmol + 1\nuSmol::Float32 : u - uBig\nuBig::Float32 : (m2-m3)^2 = 1 (normalised units) -> u = uSmol + 1\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.dsigmadt_PhoPhoElePos-NTuple{6, Float32}","page":"Internal Functions","title":"BinaryInteractionSpectra.dsigmadt_PhoPhoElePos","text":"dsigmadt_PhoPhoElePos(sSmol,sBig,tSmol,tBig,uSmol,uBig)\n\nreturns the differential cross section for photon-photon annihilation to electron-positron pair. \n\nArguments\n\nsSmol::Float32 : s - sBig\nsBig::Float32 : (m1+m2)^2 = 0 (normalised units) -> s = sSmol\ntSmol::Float32 : t - tBig\ntBig::Float32 : (m3-m1)^2 = 1 (normalised units) -> t = tSmol + 1\nuSmol::Float32 : u - uBig\nuBig::Float32 : (m2-m3)^2 = 1 (normalised units) -> u = uSmol + 1\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.dsigmadt_SphSphSphSph-NTuple{6, Float32}","page":"Internal Functions","title":"BinaryInteractionSpectra.dsigmadt_SphSphSphSph","text":"dsigmadt_SphSphSphSph(sSmol,sBig,tSmol,tBig,uSmol,uBig)\n\nreturns the differential cross section for the binary interaction of hard spheres with normalised masses m1,m2,m3,m4\n\nArguments\n\nsSmol::Float32 : s - sBig\nsBig::Float32 : (m1+m2)^2\ntSmol::Float32 : t - tBig\ntBig::Float32 : (m3-m1)^2\nuSmol::Float32 : u - uBig\nuBig::Float32 : (m2-m3)^2\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.location-Tuple{Float32, Float32, Int64, Float32}","page":"Internal Functions","title":"BinaryInteractionSpectra.location","text":"location(u,l,num,val)\n\nReturns the index of the bin in which 'val' is contatined based on the 'num' of bins and their 'u' upper and 'l' lower bound.\n\nExamples\n\njulia> location(10f0,0f0,9,2f0)\n2\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.location_p3-Tuple{Float32, Float32, Int64, Float32}","page":"Internal Functions","title":"BinaryInteractionSpectra.location_p3","text":"location_p3(u,l,num,val)\n\nReturns the index of the bin in which 'val' is contatined based on the 'num' of bins and their 'u' upper and 'l' lower bound including overflow and underflow possibilities. Overflow are assigned to num+1 while underflow are assigned to lowest bin i.e. 1.\n\nExamples\n\njulia> location_p3(10f0,1f0,9,2f0)\n2\njulia> location_p3(10f0,1f0,9,11f0) # overflow\n10\njulia> location_p3(10f0,1f0,9,0.5f0) # underflow\n1\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.location_t-Tuple{Int64, Float32}","page":"Internal Functions","title":"BinaryInteractionSpectra.location_t","text":"location_t(numt,val)\n\nReturns the index of the bin in which the costheta 'val' is contatined based on the 'numt' of bins. Bounds [tl tu] are defined as CONST in Init.jl\n\nExamples\n\njulia> location_t(8,0.5f0)\n6\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.meanVector-Tuple{Vector{Float32}}","page":"Internal Functions","title":"BinaryInteractionSpectra.meanVector","text":"meanVector(valr)\n\nInputs a (num+1) vector{Float32} of domain bounds and returns a (num) vector{Float32} of mean value in domain range.\n\nExamples\n\njulia> meanVector([1.0f0, 10.0f0, 100.0f0, 1000.0f0])\n3-element Vector{Float32}:\n 5.5\n 55.0\n 550.0\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.prange-Tuple{Float32, Float32, Int64}","page":"Internal Functions","title":"BinaryInteractionSpectra.prange","text":"prange(pl,pu,nump)\n\nReturns a (nump+1) vector{Float32} of p-space grid bounds NOT in Log10 space.\n\nExamples\n\njulia> prange(-5f0,4f0,9)\n10-element Vector{Float32}:\n 1.0e-5\n 1.0e-4\n 1.0e-3\n 0.01\n 0.1\n 1.0\n 10.0\n 100.0\n 1000.0\n 10000.0\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.sCheck-Tuple{Float32, Float32}","page":"Internal Functions","title":"BinaryInteractionSpectra.sCheck","text":"sCheck(sSmol,sBig)\n\nReturns 'true' if 's' mandelstram generated from inital system state can generate a physical output state. \n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.sigma_ElePosPhoPho-Tuple{Float32, Float32}","page":"Internal Functions","title":"BinaryInteractionSpectra.sigma_ElePosPhoPho","text":"sigma_ElePosPhoPho(sSmol,sBig)\n\nreturns the total cross section for electron positron annihilation to two photons. Berestetskii 1982 (88.6)\n\nArguments\n\nsSmol::Float32 : s - sBig\nsBig::Float32 : (m1+m2)^2 = 4 (normalised units) -> s = sSmol + 4\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.sigma_PhoPhoElePos-Tuple{Float32, Float32}","page":"Internal Functions","title":"BinaryInteractionSpectra.sigma_PhoPhoElePos","text":"sigma_PhoPhoElePos(sSmol,sBig)\n\nreturns the total cross section for photon-photon annihilation to electron-positron pair.\n\nArguments\n\nsSmol::Float32 : s - sBig\nsBig::Float32 : (m1+m2)^2 = 0 (normalised units) -> s = sSmol\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.sigma_SphSphSphSph-Tuple{Float32, Float32}","page":"Internal Functions","title":"BinaryInteractionSpectra.sigma_SphSphSphSph","text":"sigma_SphSphSphSph(sSmol,sBig)\n\nreturns the total cross section for the binary interaction of hard spheres with normalised masses m1,m2,m3,m4\n\nArguments\n\nsSmol::Float32 : s - sBig\nsBig::Float32 : (m1+m2)^2\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.trange-Tuple{Int64}","page":"Internal Functions","title":"BinaryInteractionSpectra.trange","text":"trange(numt)\n\nReturns a (numt+1) vector{Float32} of theta-space grid bounds in terms of cos(theta). Upper and lower bounds [tl tu] are defined as CONST in Init.jl as [-1f0 1f0].\n\nExamples\n\njulia> trange(8)\n9-element Vector{Float32}:\n -1.0\n -0.75\n -0.5\n -0.25\n  0.0\n  0.25\n  0.5\n  0.75\n  1.0\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/#BinaryInteractionSpectra.vectorLocation-Tuple{Float32, Float32, Int64, Int64, Vector{Float32}}","page":"Internal Functions","title":"BinaryInteractionSpectra.vectorLocation","text":"vectorLocation(pu,pl,nump,numt,vector)\n\nReturns a tuple of bin location for (log10momentum,cos(theta)) based on an input 'vector' and bounds 'u,l' of their domains and the 'num' of uniformly spaced bins. costheta bounds [tl tu] are defined as CONST in Init.jl\n\nExamples\n\n```julia-repl julia> vectorLocation(4f0,-5f0,9,8,[1f0,0.5f0,1.5f0]) (5,6)\n\n\n\n\n\n","category":"method"},{"location":"internalfunctions/","page":"Internal Functions","title":"Internal Functions","text":"prange\ntrange\ndeltaVector\nmeanVector\ndeltaEVector","category":"page"},{"location":"internalfunctions/#BinaryInteractionSpectra.prange","page":"Internal Functions","title":"BinaryInteractionSpectra.prange","text":"prange(pl,pu,nump)\n\nReturns a (nump+1) vector{Float32} of p-space grid bounds NOT in Log10 space.\n\nExamples\n\njulia> prange(-5f0,4f0,9)\n10-element Vector{Float32}:\n 1.0e-5\n 1.0e-4\n 1.0e-3\n 0.01\n 0.1\n 1.0\n 10.0\n 100.0\n 1000.0\n 10000.0\n\n\n\n\n\n","category":"function"},{"location":"internalfunctions/#BinaryInteractionSpectra.trange","page":"Internal Functions","title":"BinaryInteractionSpectra.trange","text":"trange(numt)\n\nReturns a (numt+1) vector{Float32} of theta-space grid bounds in terms of cos(theta). Upper and lower bounds [tl tu] are defined as CONST in Init.jl as [-1f0 1f0].\n\nExamples\n\njulia> trange(8)\n9-element Vector{Float32}:\n -1.0\n -0.75\n -0.5\n -0.25\n  0.0\n  0.25\n  0.5\n  0.75\n  1.0\n\n\n\n\n\n","category":"function"},{"location":"internalfunctions/#BinaryInteractionSpectra.deltaVector","page":"Internal Functions","title":"BinaryInteractionSpectra.deltaVector","text":"deltaVector(valr)\n\nInputs a (num+1) vector{Float32} quantitiy values (domain bounds) and returns a (num) vector{Float32} of differeces (domain widths).\n\nExamples\n\njulia> deltaVector([1.0f0, 10.0f0, 100.0f0, 1000.0f0])\n3-element Vector{Float32}:\n 9.0\n 90.0\n 900.0\n\n\n\n\n\n","category":"function"},{"location":"internalfunctions/#BinaryInteractionSpectra.meanVector","page":"Internal Functions","title":"BinaryInteractionSpectra.meanVector","text":"meanVector(valr)\n\nInputs a (num+1) vector{Float32} of domain bounds and returns a (num) vector{Float32} of mean value in domain range.\n\nExamples\n\njulia> meanVector([1.0f0, 10.0f0, 100.0f0, 1000.0f0])\n3-element Vector{Float32}:\n 5.5\n 55.0\n 550.0\n\n\n\n\n\n","category":"function"},{"location":"internalfunctions/#BinaryInteractionSpectra.deltaEVector","page":"Internal Functions","title":"BinaryInteractionSpectra.deltaEVector","text":"deltaEVector(pr,mu)\n\nInputs a (num+1) vector{Float32} of p grid boundries and the particle mu value and returns a (num) vector{Float32} of average energy values per grid cell.\n\nExamples\n\njulia> deltaEVector([1.0f0, 10.0f0, 100.0f0, 1000.0f0], 1.0f0)\n3-element Vector{Float32}:\n 50.600693\n 4951.15\n 495001.16\n\n\n\n\n\n","category":"function"},{"location":"internalfunctions/","page":"Internal Functions","title":"Internal Functions","text":"TValue\nSValue\nInvarientFlux\nInvarientFlux2\nInvarientFluxSmall\nInvarientFlux2Small","category":"page"},{"location":"internalfunctions/#BinaryInteractionSpectra.TValue","page":"Internal Functions","title":"BinaryInteractionSpectra.TValue","text":"TValue(p1v,p2v,sigma)\n\nreturns Tval with its Tval from MC integration based on initial momentum states p1v and p2v and cross section sigma based on particle selection. If initial state fails sCheck, i.e. cannot generate a physical output state, Tval is set to 0f0.  Assumes f(x,p,μ)=constant over bin\n\n\n\n\n\n","category":"function"},{"location":"internalfunctions/#BinaryInteractionSpectra.SValue","page":"Internal Functions","title":"BinaryInteractionSpectra.SValue","text":"SValue(p3v,p1v,p2v,dsigmadt)\n\nReturns Sval from MC integration based on initial momentum states p1v and p2v and final state p3v and differential cross section dsigmadt based on particle selection.   Assumes f(x,p,μ)=constant over bin\n\n\n\n\n\n","category":"function"},{"location":"internalfunctions/#BinaryInteractionSpectra.InvarientFlux","page":"Internal Functions","title":"BinaryInteractionSpectra.InvarientFlux","text":"InvarientFlux(s,mass12,mass22)\n\nreturns the value of the invarient flux with 's' mandelstram variable and masses 'mass1' and 'mass2'\n\n\n\n\n\n","category":"function"},{"location":"internalfunctions/#BinaryInteractionSpectra.InvarientFlux2","page":"Internal Functions","title":"BinaryInteractionSpectra.InvarientFlux2","text":"InvarientFlux2(s,mass12,mass22)\n\nreturns the value of the squared invarient flux with 's' mandelstram variable and masses 'mass1' and 'mass2'\n\n\n\n\n\n","category":"function"},{"location":"internalfunctions/#BinaryInteractionSpectra.InvarientFluxSmall","page":"Internal Functions","title":"BinaryInteractionSpectra.InvarientFluxSmall","text":"InvarientFluxSmall(sSmol,mass12,mass22)\n\nreturns the value of the invarient flux with smalled 's' mandelstram variable (sSmol = s - (m1+m2)^2)\n\n\n\n\n\n","category":"function"},{"location":"internalfunctions/#BinaryInteractionSpectra.InvarientFlux2Small","page":"Internal Functions","title":"BinaryInteractionSpectra.InvarientFlux2Small","text":"InvarientFluxSmall(sSmol,mass12,mass22)\n\nreturns the value of the squared invarient flux with smalled 's' mandelstram variable (sSmol = s - (m1+m2)^2)\n\n\n\n\n\n","category":"function"},{"location":"internalfunctions/","page":"Internal Functions","title":"Internal Functions","text":"STMonteCarloAxi_MultiThread!\nSTMonteCarloAxi_Serial!","category":"page"},{"location":"internalfunctions/#BinaryInteractionSpectra.STMonteCarloAxi_MultiThread!","page":"Internal Functions","title":"BinaryInteractionSpectra.STMonteCarloAxi_MultiThread!","text":"STMonteCarloAxi_MultiThread!(SAtotal,TAtotal,SAtally,TAtally,p3v,p3pv,p1v,p2v,p3Max,t3MinMax})\n\nArguments\n\nSAtotal::Array{Float32,6} : Array of stored integration totals for S matrix\nTAtotal::Array{Float32,4} : Array of stored integration totals for T matrix\nSAtally::Array{UInt32,5} : Array of stored integration tallies for S matrix\nTAtally::Array{UInt32,4} : Array of stored integration tallies for T matrix\np3v::Vector{Float32} : Vector of momentum values for species 3\np3pv::Vector{Float32} : Second Vector of momentum values for species 3 for when two states are possible\np1v::Vector{Float32} : Vector of momentum values for species 1\np2v::Vector{Float32} : Vector of momentum values for species 2\np3Max::Array{Float32,5} : Array of maximum momentum values for species 3\nt3MinMax::Array{Float32,6} : Array of minimum and maximum theta values for species 3\n\nOutput:\n\nArgument arrays SAtotal,TAtotal,SAtally,TAtally are mutated to include the results of the Monte Carlo Integration.\n\nHidden Inputs (defined in Init.jl)\n\nDomain Boundaries (defined as CONST)       - p bounds and divisions for species 1,3,4       - theta divisions for species 1,3,4 ( bounds not needed as assumed [-1,1] )       - phi divisions for species 1,3,4 ( bounds not needed as assumed [0,2] )\nParticle Masses (defined as CONST)\nnumTiterPerThread and numSiterPerThread as the number of T and S integrations to perform.\n\nCalculation In Breif\n\nSet up worker threads\nRandom Sample points in each of these domains\nRandomPointSphere for theta and phi (for species 1,2,3)\nRandomPointMomentum for p ( species 1,2 only )\nTake random points (t3,h1,p1,p2,t1,t2,h3,h4) and calculate valid p3 point/points \nFind position in local S and T arrays and allocated tallies and totals accordingly.\nUpdate global S and T arrays with locks to prevent data races\n\n\n\n\n\n","category":"function"},{"location":"internalfunctions/#BinaryInteractionSpectra.STMonteCarloAxi_Serial!","page":"Internal Functions","title":"BinaryInteractionSpectra.STMonteCarloAxi_Serial!","text":"STMonteCarloAxi_Serial!(SAtotal,TAtotal,SAtally,TAtally,p3v,p3pv,p1v,p2v,p3Max,t3MinMax})\n\nArguments\n\nSAtotal::Array{Float32,6} : Array of stored integration totals for S matrix\nTAtotal::Array{Float32,4} : Array of stored integration totals for T matrix\nSAtally::Array{UInt32,5} : Array of stored integration tallies for S matrix\nTAtally::Array{UInt32,4} : Array of stored integration tallies for T matrix\np3v::Vector{Float32} : Vector of momentum values for species 3\np3pv::Vector{Float32} : Second Vector of momentum values for species 3 for when two states are possible\np1v::Vector{Float32} : Vector of momentum values for species 1\np2v::Vector{Float32} : Vector of momentum values for species 2\np3Max::Array{Float32,5} : Array of maximum momentum values for species 3\nt3MinMax::Array{Float32,6} : Array of minimum and maximum theta values for species 3\n\nOutput:\n\nArgument arrays SAtotal,TAtotal,SAtally,TAtally are mutated to include the results of the Monte Carlo Integration.\n\nHidden Inputs (defined in Init.jl)\n\nDomain Boundaries (defined as CONST)       - p bounds and divisions for species 1,3,4       - theta divisions for species 1,3,4 ( bounds not needed as assumed [-1,1] )       - phi divisions for species 1,3,4 ( bounds not needed as assumed [0,2] )\nParticle Masses (defined as CONST)\nnumTiter and numSiter as the number of T and S integrations to perform.\n\nCalculation In Breif\n\nRandom Sample points in each of these domains\nRandomPointSphere for theta and phi (for species 1,2,3)\nRandomPointMomentum for p ( species 1,2 only )\nTake random points (t3,h1,p1,p2,t1,t2,h3,h4) and calculate valid p3 point/points \nFind position in S and T arrays and allocated tallies and totals accordingly.\n\n\n\n\n\n","category":"function"},{"location":"internalfunctions/","page":"Internal Functions","title":"Internal Functions","text":"PhaseSpaceFactors1!\nPhaseSpaceFactors2!\nSTSymmetry!","category":"page"},{"location":"internalfunctions/#BinaryInteractionSpectra.PhaseSpaceFactors1!","page":"Internal Functions","title":"BinaryInteractionSpectra.PhaseSpaceFactors1!","text":"PhaseSpaceFactors1!(SMatrix,TMatrix,t3val,p1val,t1val,p2val,t2val)\n\nApplies phase space volume element factors for 'SMatrix' and 'TMatrix' terms in order to correctly apply 'STSymmetry' corrections. \n\n\n\n\n\n","category":"function"},{"location":"internalfunctions/#BinaryInteractionSpectra.PhaseSpaceFactors2!","page":"Internal Functions","title":"BinaryInteractionSpectra.PhaseSpaceFactors2!","text":"PhaseSpaceFactors2!(SMatrix,TMatrix,t3val,p1val,t1val,p2val,t2val)\n\nTo follow 'PhaseSpaceFactors1' and 'STSymmetry'. Corrects phase space factors on 'SMatrix' and 'TMatrix' for use in kinetic codes. Assumes f(x,p,μ)= constant\n\n\n\n\n\n","category":"function"},{"location":"internalfunctions/#BinaryInteractionSpectra.STSymmetry!","page":"Internal Functions","title":"BinaryInteractionSpectra.STSymmetry!","text":"STSymmetry!(SMatrix,TMatrix,t3val,p1val,t1val,p2val,t2val)\n\nTo follow 'PhaseSpaceFactors1'. Physical nature of binary interaction has certain symmetries. 'STSymmetry' uses these symmetries to improve MC sampling of 'SMatrix' and 'TMatrix'.\n\n\n\n\n\n","category":"function"},{"location":"internalfunctions/","page":"Internal Functions","title":"Internal Functions","text":"sCheck","category":"page"},{"location":"internalfunctions/#BinaryInteractionSpectra.sCheck","page":"Internal Functions","title":"BinaryInteractionSpectra.sCheck","text":"sCheck(sSmol,sBig)\n\nReturns 'true' if 's' mandelstram generated from inital system state can generate a physical output state. \n\n\n\n\n\n","category":"function"},{"location":"internalfunctions/","page":"Internal Functions","title":"Internal Functions","text":"location\nlocation_p3\nlocation_t\nvectorLocation","category":"page"},{"location":"internalfunctions/#BinaryInteractionSpectra.location","page":"Internal Functions","title":"BinaryInteractionSpectra.location","text":"location(u,l,num,val)\n\nReturns the index of the bin in which 'val' is contatined based on the 'num' of bins and their 'u' upper and 'l' lower bound.\n\nExamples\n\njulia> location(10f0,0f0,9,2f0)\n2\n\n\n\n\n\n","category":"function"},{"location":"internalfunctions/#BinaryInteractionSpectra.location_p3","page":"Internal Functions","title":"BinaryInteractionSpectra.location_p3","text":"location_p3(u,l,num,val)\n\nReturns the index of the bin in which 'val' is contatined based on the 'num' of bins and their 'u' upper and 'l' lower bound including overflow and underflow possibilities. Overflow are assigned to num+1 while underflow are assigned to lowest bin i.e. 1.\n\nExamples\n\njulia> location_p3(10f0,1f0,9,2f0)\n2\njulia> location_p3(10f0,1f0,9,11f0) # overflow\n10\njulia> location_p3(10f0,1f0,9,0.5f0) # underflow\n1\n\n\n\n\n\n","category":"function"},{"location":"internalfunctions/#BinaryInteractionSpectra.location_t","page":"Internal Functions","title":"BinaryInteractionSpectra.location_t","text":"location_t(numt,val)\n\nReturns the index of the bin in which the costheta 'val' is contatined based on the 'numt' of bins. Bounds [tl tu] are defined as CONST in Init.jl\n\nExamples\n\njulia> location_t(8,0.5f0)\n6\n\n\n\n\n\n","category":"function"},{"location":"internalfunctions/#BinaryInteractionSpectra.vectorLocation","page":"Internal Functions","title":"BinaryInteractionSpectra.vectorLocation","text":"vectorLocation(pu,pl,nump,numt,vector)\n\nReturns a tuple of bin location for (log10momentum,cos(theta)) based on an input 'vector' and bounds 'u,l' of their domains and the 'num' of uniformly spaced bins. costheta bounds [tl tu] are defined as CONST in Init.jl\n\nExamples\n\n```julia-repl julia> vectorLocation(4f0,-5f0,9,8,[1f0,0.5f0,1.5f0]) (5,6)\n\n\n\n\n\n","category":"function"},{"location":"internalfunctions/","page":"Internal Functions","title":"Internal Functions","text":"RPointSphereCosThetaPhi!\nRPointLogMomentum!","category":"page"},{"location":"internalfunctions/#BinaryInteractionSpectra.RPointSphereCosThetaPhi!","page":"Internal Functions","title":"BinaryInteractionSpectra.RPointSphereCosThetaPhi!","text":"RPointSphereThetaPhi!()\n\nAssigns the second (cos(theta)) and third (phi) elements of 'a' with a randomly, uniformly sampled values of spherical angles cos(theta) and phi (phi normalised by pi). \n\n\n\n\n\n","category":"function"},{"location":"internalfunctions/#BinaryInteractionSpectra.RPointLogMomentum!","page":"Internal Functions","title":"BinaryInteractionSpectra.RPointLogMomentum!","text":"RPointLogMomentum!(pu,pl,pv,num)\n\nEdits the first element of 'pv' with a random real-space momentum value between 10^pl and 10^pu. This sample is chosen by first randomly picking a momentum bin in the range 1:num and then uniformly sampling a momentum point in real-space (rather than log10 space) between l and u which are the momentum values at start and end of that bin. Sampling is done such there will be a constant number of points per momentum-space volume. As the momentum space between 10^pl and 10^pu it is a spherical shell hence the correct sampling is p = (U(10^pu)^3+(1-U)(10^pl)^3)^1/3 with uniform U ∈ [0 1].\n\nAssumes f(xpμ)=f(xvecp)*(2pi p^2)=const in bin, therefore momentum space volume element is dp and as such uniform sampling corresponds to U*10^(u)+(1-U)*10^(l) where U is a uniform random number between 0 and 1.\n\nIf instead f(xvecp)=const in bin, momentum space volume element is p^2 dp and uniform sampling corresponds to (10^u)*cbrt(U+(1-U)*10^(3l-3u)) where U is a uniform random number between 0 and 1.\n\n\n\n\n\n","category":"function"},{"location":"internalfunctions/","page":"Internal Functions","title":"Internal Functions","text":"Momentum3Value!","category":"page"},{"location":"internalfunctions/#BinaryInteractionSpectra.Momentum3Value!","page":"Internal Functions","title":"BinaryInteractionSpectra.Momentum3Value!","text":"Momentum3Value!(p3v,p3pv,p1v,p2v)\n\nTakes set of random initial particle states 'p1v' and 'p2v' and random output states angles 'p3v[2:3]' and modifies outputs 'p3v' and 'p3pv' values with calculated output momentum and corrects angles if momentum is negative. Function also returns a two bools 'p3physical' and 'p3pphysical' indicating if p3 and p3p are physical momentum states given the inputs.  Function also returns a Int 'NumStates' indicating the number of valid output states found.\n\nRequrires normalised masses (mu1,mu2,mu3,mu4) to be defined in advance in Init.jl as const.\n\nExamples\n\njulia> mu1 = 1836.1528f0\njulia> mu2 = 1836.1528f0\njulia> mu3 = 1836.1528f0\njulia> mu4 = 1836.1528f0\njulia> p1v = [1f0, 0.5f0, 1.8f0]\njulia> p2v = [2f0, 0.2f0, 0.7f0]\njulia> p3v = [0f0, 0.3f0, 0.7f0]\njulia> p3pv = zeros(Float32,3)\njulia> p3pv .= p3v\njulia> Momentum3Value!(p3v,p3pv,p1v,p2v)\n(true,true,2)\njulia> p3v\n 3-element Vector{Float32}:\n 2.04505\n 0.3\n 0.7\njulia> p3pv\n 3-element Vector{Float32}\n 0.691423\n -0.3\n 1.7\n\n\n\n\n\n","category":"function"},{"location":"crosssections/#Cross-Sections","page":"Cross Sections","title":"Cross Sections","text":"","category":"section"},{"location":"crosssections/","page":"Cross Sections","title":"Cross Sections","text":"Below is a list of the currently available binary interaction cross sections that have been implemented:","category":"page"},{"location":"crosssections/","page":"Cross Sections","title":"Cross Sections","text":"Collision of hard spheres SphSphSphSph\nPhoton pair production from electron positron annihilation ElePosPhoPho\nElectron positron pair production from photon pair annihilation PhoPhoElePos","category":"page"},{"location":"crosssections/#Differential-and-total-cross-section-functions:","page":"Cross Sections","title":"Differential and total cross section functions:","text":"","category":"section"},{"location":"crosssections/","page":"Cross Sections","title":"Cross Sections","text":"CurrentModule = BinaryInteractionSpectra\nusing BinaryInteractionSpectra\nend","category":"page"},{"location":"crosssections/","page":"Cross Sections","title":"Cross Sections","text":"sigma_SphSphSphSph\ndsigmadt_SphSphSphSph\n\nsigma_ElePosPhoPho\ndsigmadt_ElePosPhoPho\n\nsigma_PhoPhoElePos\ndsigmadt_PhoPhoElePos","category":"page"},{"location":"crosssections/#BinaryInteractionSpectra.sigma_SphSphSphSph","page":"Cross Sections","title":"BinaryInteractionSpectra.sigma_SphSphSphSph","text":"sigma_SphSphSphSph(sSmol,sBig)\n\nreturns the total cross section for the binary interaction of hard spheres with normalised masses m1,m2,m3,m4\n\nArguments\n\nsSmol::Float32 : s - sBig\nsBig::Float32 : (m1+m2)^2\n\n\n\n\n\n","category":"function"},{"location":"crosssections/#BinaryInteractionSpectra.dsigmadt_SphSphSphSph","page":"Cross Sections","title":"BinaryInteractionSpectra.dsigmadt_SphSphSphSph","text":"dsigmadt_SphSphSphSph(sSmol,sBig,tSmol,tBig,uSmol,uBig)\n\nreturns the differential cross section for the binary interaction of hard spheres with normalised masses m1,m2,m3,m4\n\nArguments\n\nsSmol::Float32 : s - sBig\nsBig::Float32 : (m1+m2)^2\ntSmol::Float32 : t - tBig\ntBig::Float32 : (m3-m1)^2\nuSmol::Float32 : u - uBig\nuBig::Float32 : (m2-m3)^2\n\n\n\n\n\n","category":"function"},{"location":"crosssections/#BinaryInteractionSpectra.sigma_ElePosPhoPho","page":"Cross Sections","title":"BinaryInteractionSpectra.sigma_ElePosPhoPho","text":"sigma_ElePosPhoPho(sSmol,sBig)\n\nreturns the total cross section for electron positron annihilation to two photons. Berestetskii 1982 (88.6)\n\nArguments\n\nsSmol::Float32 : s - sBig\nsBig::Float32 : (m1+m2)^2 = 4 (normalised units) -> s = sSmol + 4\n\n\n\n\n\n","category":"function"},{"location":"crosssections/#BinaryInteractionSpectra.dsigmadt_ElePosPhoPho","page":"Cross Sections","title":"BinaryInteractionSpectra.dsigmadt_ElePosPhoPho","text":"dsigmadt_ElePosPhoPho(sSmol,sBig,tSmol,tBig,uSmol,uBig)\n\nreturns the differential cross section for electron positron annihilation to two photons. Berestetskii 1982 (88.4)\n\nArguments\n\nsSmol::Float32 : s - sBig\nsBig::Float32 : (m1+m2)^2 = 4 (normalised units) -> s = sSmol + 4\ntSmol::Float32 : t - tBig\ntBig::Float32 : (m3-m1)^2 = 1 (normalised units) -> t = tSmol + 1\nuSmol::Float32 : u - uBig\nuBig::Float32 : (m2-m3)^2 = 1 (normalised units) -> u = uSmol + 1\n\n\n\n\n\n","category":"function"},{"location":"crosssections/#BinaryInteractionSpectra.sigma_PhoPhoElePos","page":"Cross Sections","title":"BinaryInteractionSpectra.sigma_PhoPhoElePos","text":"sigma_PhoPhoElePos(sSmol,sBig)\n\nreturns the total cross section for photon-photon annihilation to electron-positron pair.\n\nArguments\n\nsSmol::Float32 : s - sBig\nsBig::Float32 : (m1+m2)^2 = 0 (normalised units) -> s = sSmol\n\n\n\n\n\n","category":"function"},{"location":"crosssections/#BinaryInteractionSpectra.dsigmadt_PhoPhoElePos","page":"Cross Sections","title":"BinaryInteractionSpectra.dsigmadt_PhoPhoElePos","text":"dsigmadt_PhoPhoElePos(sSmol,sBig,tSmol,tBig,uSmol,uBig)\n\nreturns the differential cross section for photon-photon annihilation to electron-positron pair. \n\nArguments\n\nsSmol::Float32 : s - sBig\nsBig::Float32 : (m1+m2)^2 = 0 (normalised units) -> s = sSmol\ntSmol::Float32 : t - tBig\ntBig::Float32 : (m3-m1)^2 = 1 (normalised units) -> t = tSmol + 1\nuSmol::Float32 : u - uBig\nuBig::Float32 : (m2-m3)^2 = 1 (normalised units) -> u = uSmol + 1\n\n\n\n\n\n","category":"function"},{"location":"quickstart/#getting_started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"#BinaryInteractionSpectra.jl","page":"Overview","title":"BinaryInteractionSpectra.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"BinaryInteractionSpectra.jl is a package for the evaluation of the collision integral from binary interactions of arbitrary momentum and anisotropic particle distributions using a method of discretisation and Monte-Carlo integration. ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The evaluation of the collision integral is of great use when studying kinetic system. The evolution of particle distributions f(x^aboldsymbolp) within such a system is dictated by the collisional relativistic Boltzmann equation (neglecting external forcing):","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"p_1^nupartial_nu f(x^muboldsymbolp_1)=C(x^muboldsymbolp_1)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"where p^mu=(p^0boldsymbolp) is the 4-Momentum and C(x^aboldsymbolp) is the collision integral. The collision integral is given by ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"    C(boldsymbolp_1)=intfracmathrmd^3boldsymbolp_2p_2^0fracmathrmd^3boldsymbolp_3p_3^0fracmathrmd^3boldsymbolp_4p_4^0leftfracf(boldsymbolp_3)f(boldsymbolp_4)1+updelta_34W(p_3^mup_4^mup_1^mup_2^mu)- fracf(boldsymbolp_1)f(boldsymbolp_2)1+updelta_34W(p_1^mup_2^mup_3^mup_4^mu)right","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"with the transition rate W being given by:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"W(p_1^mup_2^mup_3^mup_4^mu)=fracsp_textin^*2pisigma_1234(st)updelta^(4)(p_1^mu+p_2^mu-p_3^mu-p_4^mu) ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The Boltzmann equation can then be discretised in momentum space by integrating over a discrete volume element Delta^3boldsymbolp_1 to yield: ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"int_Delta^3boldsymbolp_1fracmathrmd^3boldsymbolp_1p_1^0p_1^mupartial_mu f(x^muboldsymbolp_1)=int_Delta^3boldsymbolp_1mathrmd^3boldsymbolp_1S_spe(x^muboldsymbolp_1)-T_spe(x^muboldsymbolp_1)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"where the collision integral has been split into two parts, an emission spectrum","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"S_textspe(boldsymbolp_1)=frac11+updelta_34frac1p^0_1intfracmathrmd^3boldsymbolp_2p_2^0fracmathrmd^3boldsymbolp_3p_3^0fracmathrmd^3boldsymbolp_4p_4^0f(boldsymbolp_3)f(boldsymbolp_4)W(p_3^mup_4^mup_1^mup_2^mu)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"math dictating the rate of gain of particles of a specific type at a specific momentum from a binary interaction, and an absorption spectrum ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"T_textspe(boldsymbolp_1)=frac11+updelta_34frac1p^0_1intfracmathrmd^3boldsymbolp_2p_2^0fracmathrmd^3boldsymbolp_3p_3^0fracmathrmd^3boldsymbolp_4p_4^0 f(boldsymbolp_1)f(boldsymbolp_2)W(p_1^mup_2^mup_3^mup_4^mu)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"dictating the rate of loss of particles of a specific type at a specific momentum from the same interaction.","category":"page"},{"location":"#Assumptions","page":"Overview","title":"Assumptions","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"In order to enable the evaluation of the emission and absorption terms, we make the following set of assumptions (dropping dependence on space-time for notational simplicity):  ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The system is axisymmetric in momentum space coordinates i.e. only dependant on p=boldsymbolp and the cosine of the angle to the axis of symmetry (hatz) mu where hatzcdotboldsymbolp=pcostheta=pmu \nThe distribution functions are redefined in an axisymmetric form i.e. f(boldsymbolp)equivfracf(pmu)2pi p^2. This is done such that a single particle is described by the distribution f(pmu)=delta(p-p_i)delta(mu-mu_i).\nThe axisymmetric distribution functions are averaged over phase space intervals Delta pDeltamu, to generate discrete values i.e. f(tp_imu_j)=frac1Delta p_iDeltamu_jint_Delta p_iDeltamu_j mathrmdp mathrmdmuf(pmu), such that they act as if they are constant over that interval of phase space.  ","category":"page"},{"location":"#Discrete-Form-of-the-Boltzmann-Equation","page":"Overview","title":"Discrete Form of the Boltzmann Equation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Following the assumptions laid out in the previous section. The axisymmetric, momentum-discrete Boltzmann equation is given by ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"left(partial_t+braketbeta_ibraketmu_jpartial_zright)f_1ij=f_3klf_4mnS_3412ijklmn-f_1ijf_2klT_1234ijkl","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The discrete emission spectrum term is a 6D array, given by","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"f_3klf_4mnS_3412ijklmn=f(ztp_3kmu_3l)f(ztp_4mmu_4n)fracDelta p_3kDelta mu_3lDelta p_4mDelta mu_4nDelta p_ifrac1Nsum^N_a=1leftS_valright(boldsymbolp_1boldsymbolp_3boldsymbolp_4_a) ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"with ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"S_val=frac1+delta_121+delta_34sum_pmfrac2p_pm^2mathcalF_34^2 p_3^0p_4^0fracdsigma_3412dt(st_pm)frac1p_3^0p_pm-p_pm^0p_3cosTheta_pm3+p_4^0p_pm-p_pm^0p_4cosTheta_pm4","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"while the discrete absorption term is a 4D Array, given by","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"f_1ijf_2klT_1234ijkl=f(ztp_imu_j)f(ztp_2kmu_2l)Deltaboldsymbolp_2kDeltamu_2lfrac1Nsum^N_a=1leftT_valright(boldsymbolp_1boldsymbolp_2_a)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"with","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"T_val=frac11+delta_12fracmathcalF_12(s)sigma_1234(s)p^0p_2^0","category":"page"},{"location":"#Evaluation","page":"Overview","title":"Evaluation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Given a user input of interaction to evaluate and what discretisation to use, the discrete emission spectrum S_1234ijklmn (note the change of order of the interaction) and absorption spectrum T_1234ijkl are solved simultaneously by Monte-Carlo integration. The evaluation is performed by the functions SpectraEvaluateSerial() or SpectralEvaluateMultiThread() depending on if the code is to run in serially on a single core or multi-threaded on multiple cores of a single CPU. The code will then save the resulting multidimensional arrays.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"!!! warning The evaluation does not guarantee convergence of the Monte-Carlo integration, instead it will sample only a user defined number of points. A rough measure of convergence is calculated and stored as SConverge and TConverge in the output file.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"A quick setup guide is provided in the Getting Startedsection.  ","category":"page"}]
}
