<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internal Functions · BoltzmannCollisionIntegral.jl</title><meta name="title" content="Internal Functions · BoltzmannCollisionIntegral.jl"/><meta property="og:title" content="Internal Functions · BoltzmannCollisionIntegral.jl"/><meta property="twitter:title" content="Internal Functions · BoltzmannCollisionIntegral.jl"/><meta name="description" content="Documentation for BoltzmannCollisionIntegral.jl."/><meta property="og:description" content="Documentation for BoltzmannCollisionIntegral.jl."/><meta property="twitter:description" content="Documentation for BoltzmannCollisionIntegral.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="BoltzmannCollisionIntegral.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="BoltzmannCollisionIntegral.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">BoltzmannCollisionIntegral.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../quickstart/">Getting Started</a></li><li><a class="tocitem" href="../crosssections/">Grids, Particles and Cross Sections</a></li><li><a class="tocitem" href="../synchrotron/">Synchrotron Emissions</a></li><li class="is-active"><a class="tocitem" href>Internal Functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Internal Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internal Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/main/docs/src/internalfunctions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal-Functions"><a class="docs-heading-anchor" href="#Internal-Functions">Internal Functions</a><a id="Internal-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.BackwardsLorentzBoost!-Tuple{Vector{Float64}, Vector{Float64}, Float64, Float64}" href="#BoltzmannCollisionIntegral.BackwardsLorentzBoost!-Tuple{Vector{Float64}, Vector{Float64}, Float64, Float64}"><code>BoltzmannCollisionIntegral.BackwardsLorentzBoost!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BackwardsLorentzBoost!(pBv::Vector{Float64},pv::Vector{Float64},m::Float64,w::Float64)

Calculates the backwards Lorentz boost (in z direction) from the COM frame to the lab frame for the momentum vector `pv` of a particle with (normalised) mass `m` by the rapidity `w` (must be positive!), placing the results in the boosted vector `pBv``. 

Momentum vectors have coponents [p,cos(theta),phi,theta]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/Sampling.jl#L1265-L1271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.DoesConserve-NTuple{5, Any}" href="#BoltzmannCollisionIntegral.DoesConserve-NTuple{5, Any}"><code>BoltzmannCollisionIntegral.DoesConserve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DoesConserve(SMatrix3,SMatrix4,TMatrix1,TMatrix2,Parameters)</code></pre><p>Function prints the ratio of the sum of the S and T matrices and their differences, for all interaction paths, as to check number and energy conservation for a particular interaction. Arguments are as outputted by the <code>fload_All</code> function. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/DataReading.jl#L512-L516">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.DoesConserve2-Tuple{Tuple{Tuple, Array{Float64, 9}, Array{Float64, 9}, Array{Float64, 6}, Array{Float64, 6}}}" href="#BoltzmannCollisionIntegral.DoesConserve2-Tuple{Tuple{Tuple, Array{Float64, 9}, Array{Float64, 9}, Array{Float64, 6}, Array{Float64, 6}}}"><code>BoltzmannCollisionIntegral.DoesConserve2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DoesConserve(SMatrix3,SMatrix4,TMatrix1,TMatrix2,Parameters)</code></pre><p>Function prints the ratio of the sum of the S and T matrices and their differences, for all interaction paths, as to check number and energy conservation for a particular interaction. Arguments are as outputted by the <code>fload_Matrix</code> function. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/DataReading.jl#L196-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.DopplerFactor!-Tuple{Vector{Float64}, Float64, Float64}" href="#BoltzmannCollisionIntegral.DopplerFactor!-Tuple{Vector{Float64}, Float64, Float64}"><code>BoltzmannCollisionIntegral.DopplerFactor!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DopplerFactor!(pv::Vector{Float64},m::Float64,w::Float64)</code></pre><p>Computes the doppler factor aka cosine angle jacobian for a particle of mass <code>m</code> between the CM frame and lab frame, for a boost with rapididty <code>w</code> in the z direction (w must be +ve). The result is stored in the fifth entry of the vector <code>pv</code>. Which is expected to have components [p,cos(theta),phi,theta,doppler].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/Sampling.jl#L1483-L1487">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.ForwardLorentzBoost!-Tuple{Vector{Float64}, Vector{Float64}, Float64, Float64, Float64}" href="#BoltzmannCollisionIntegral.ForwardLorentzBoost!-Tuple{Vector{Float64}, Vector{Float64}, Float64, Float64, Float64}"><code>BoltzmannCollisionIntegral.ForwardLorentzBoost!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ForwardLorentzBoost!(pBv::Vector{Float64},pv::Vector{Float64},m::Float64,w::Float64,pB::Float64)

Calculates the forward Lorentz boost (in z direction) from the lab frame to the COM frame for the momentum vector `pv` of a particle with (normalised) mass `m` by the rapidity `w` (must be positive!), placing the results in the boosted vector `pBv``. Assumes boosted magnitude of momentum `pB` in the COM frame is known, therfore only computes the angle transformations.

Momentum vectors have coponents [p,cos(theta),phi,theta]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/Sampling.jl#L1045-L1051">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.GainLossSymmetry!-NTuple{10, Any}" href="#BoltzmannCollisionIntegral.GainLossSymmetry!-NTuple{10, Any}"><code>BoltzmannCollisionIntegral.GainLossSymmetry!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GainLossSymmetry(GainTotal3,GainTotal4,GainTally3,GainTally4,LossTotal,LossTally,Indistinguishable_34,m1,m2,m3,m4)</code></pre><p>Applies various physical symmetries to the Gain and Loss terms in order to improve Monte Carlo sampling error. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/MomentumSpaceFactors.jl#L166-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.ImportanceSampling-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Function, AbstractArray{Float64, 3}, AbstractArray{Float64, 3}, AbstractMatrix{UInt32}, AbstractMatrix{UInt32}, Tuple{Float64, Float64, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Float64, Float64, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Vararg{Float64, 4}}, Bool}" href="#BoltzmannCollisionIntegral.ImportanceSampling-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Function, AbstractArray{Float64, 3}, AbstractArray{Float64, 3}, AbstractMatrix{UInt32}, AbstractMatrix{UInt32}, Tuple{Float64, Float64, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Float64, Float64, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Vararg{Float64, 4}}, Bool}"><code>BoltzmannCollisionIntegral.ImportanceSampling</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ImportanceSampling()</code></pre><p>Importance MC sampling of outgoing momentum states in the boosted centre-of-momentum frame. i.e. importance sampling weighted by the de-boosting of angles from the COM frame to the Lab frame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/Sampling.jl#L297-L301">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.ImportanceSampling4!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64, Float64, Function, AbstractArray{Float64, 3}, AbstractArray{Float64, 3}, AbstractArray{UInt32, 3}, AbstractArray{UInt32, 3}, Tuple{Float64, Float64, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Float64, Float64, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Vararg{Float64, 4}}, Tuple{Float64, Float64, Float64}}" href="#BoltzmannCollisionIntegral.ImportanceSampling4!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64, Float64, Function, AbstractArray{Float64, 3}, AbstractArray{Float64, 3}, AbstractArray{UInt32, 3}, AbstractArray{UInt32, 3}, Tuple{Float64, Float64, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Float64, Float64, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Vararg{Float64, 4}}, Tuple{Float64, Float64, Float64}}"><code>BoltzmannCollisionIntegral.ImportanceSampling4!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ImportanceSampling4!()</code></pre><p>Importance MC sampling of outgoing momentum states weighted towards the direction of the incoming particle with highest momentum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/Sampling.jl#L107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.InvariantFlux-Tuple{Float64, Float64, Float64}" href="#BoltzmannCollisionIntegral.InvariantFlux-Tuple{Float64, Float64, Float64}"><code>BoltzmannCollisionIntegral.InvariantFlux</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InvariantFlux(s,mu12,mu22)</code></pre><p>returns the value of the invariant flux with &#39;s&#39; Mandelstram variable and masses &#39;mass1&#39; and &#39;mass2&#39;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/STValue.jl#L351-L355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.InvariantFlux2-Tuple{Float64, Float64, Float64}" href="#BoltzmannCollisionIntegral.InvariantFlux2-Tuple{Float64, Float64, Float64}"><code>BoltzmannCollisionIntegral.InvariantFlux2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InvariantFlux2(s,mass12,mass22)</code></pre><p>returns the value of the squared invariant flux with &#39;s&#39; Mandelstram variable and masses &#39;mass1&#39; and &#39;mass2&#39;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/STValue.jl#L376-L380">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.InvariantFlux2Small-Tuple{Float64, Float64, Float64}" href="#BoltzmannCollisionIntegral.InvariantFlux2Small-Tuple{Float64, Float64, Float64}"><code>BoltzmannCollisionIntegral.InvariantFlux2Small</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InvariantFluxSmall(sSmol,mass12,mass22)</code></pre><p>returns the value of the squared invariant flux with smalled &#39;s&#39; Mandelstram variable (sSmol = s - (m1+m2)^2)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/STValue.jl#L388-L392">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.InvariantFluxSmall-Tuple{Float64, Float64, Float64}" href="#BoltzmannCollisionIntegral.InvariantFluxSmall-Tuple{Float64, Float64, Float64}"><code>BoltzmannCollisionIntegral.InvariantFluxSmall</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InvariantFluxSmall(sSmol,mu12,mu22)</code></pre><p>returns the value of the invariant flux with smalled &#39;s&#39; Mandelstram variable (sSmol = s - (m1+m2)^2)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/STValue.jl#L363-L367">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.Momentum3Value!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vararg{Float64, 4}}" href="#BoltzmannCollisionIntegral.Momentum3Value!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vararg{Float64, 4}}"><code>BoltzmannCollisionIntegral.Momentum3Value!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Momentum3Value!(p3v,p3pv,p1v,p2v)</code></pre><p>Takes set of random initial particle states &#39;p1v&#39; and &#39;p2v&#39; and random output states angles &#39;p3v[2:3]&#39; and modifies outputs &#39;p3v&#39; and &#39;p3pv&#39; values with calculated output momentum and corrects angles if momentum is negative. Function also returns a two bools &#39;p3<em>physical&#39; and &#39;p3p</em>physical&#39; indicating if p3 and p3p are physical momentum states given the inputs.  Function also returns a Int &#39;NumStates&#39; indicating the number of valid output states found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m1 = 1836.1528e0
julia&gt; m2 = 1836.1528e0
julia&gt; m3 = 1836.1528e0
julia&gt; m4 = 1836.1528e0
julia&gt; p1v = [1e0, 0.5e0, 1.8e0]
julia&gt; p2v = [2e0, 0.2e0, 0.7e0]
julia&gt; p3v = [0e0, 0.3e0, 0.7e0]
julia&gt; p3pv = zeros(Float64,3)
julia&gt; p3pv .= p3v
julia&gt; Momentum3Value!(p3v,p3pv,p1v,p2v,m1,m2,m3,m4)
(true,true,2)
julia&gt; p3v
 3-element Vector{Float64}:
 2.04505
 0.3
 0.7
julia&gt; p3pv
 3-element Vector{Float64}
 0.691423
 -0.3
 1.7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/Momentum3Values.jl#L2-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.MomentumSpaceFactorsNew!-Tuple{Array{Float64, 9}, Array{Float64, 9}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Bool}" href="#BoltzmannCollisionIntegral.MomentumSpaceFactorsNew!-Tuple{Array{Float64, 9}, Array{Float64, 9}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Bool}"><code>BoltzmannCollisionIntegral.MomentumSpaceFactorsNew!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MomentumSpaceFactorsNew!(GainMatrix3,GainMatrix4,u3_bounds,u4_bounds,h3_bounds,h3_bounds,Indistinguishable_12)</code></pre><p>Applies momentum space volume element to the Gain and Loss matrices such that they have the correct dimensions for use in particle transport, i.e. they have units of 1/time (normalised)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/MomentumSpaceFactors.jl#L319-L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.PhaseSpaceFactors1!-Tuple{Array{Float64, 9}, Array{Float64, 9}, Array{Float64, 6}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Bool}" href="#BoltzmannCollisionIntegral.PhaseSpaceFactors1!-Tuple{Array{Float64, 9}, Array{Float64, 9}, Array{Float64, 6}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Bool}"><code>BoltzmannCollisionIntegral.PhaseSpaceFactors1!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PhaseSpaceFactors1!(SMatrix3,SMatrix4,TMatrix,u3_bounds,u4_bounds,p1_bounds,u1_bounds,p2_bounds,u2_bounds,Indistinguishable_12)</code></pre><p>Applies phase space volume element factors for &#39;SMatrix&#39; and &#39;TMatrix&#39; terms in order to correctly apply &#39;STSymmetry&#39; corrections. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/MomentumSpaceFactors.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.PhaseSpaceFactors2!-Tuple{Array{Float64, 9}, Array{Float64, 9}, Array{Float64, 6}, Array{Float64, 6}, Vararg{Vector{Float64}, 12}}" href="#BoltzmannCollisionIntegral.PhaseSpaceFactors2!-Tuple{Array{Float64, 9}, Array{Float64, 9}, Array{Float64, 6}, Array{Float64, 6}, Vararg{Vector{Float64}, 12}}"><code>BoltzmannCollisionIntegral.PhaseSpaceFactors2!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PhaseSpaceFactors2!(SMatrix3,SMatrix4,TMatrix,p3_bounds,u3_bounds,p4_bounds,u4_bounds,p1_bounds,u1_bounds,p2_bounds,u2_bounds)</code></pre><p>To follow &#39;PhaseSpaceFactors1&#39; and &#39;STSymmetry&#39;. Corrects phase space factors on &#39;SMatrix&#39; and &#39;TMatrix&#39; for use in kinetic codes. Assumes f(x,p,u,ϕ)= f(x,vec{p})/p^2=constant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/MomentumSpaceFactors.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.PhaseSpaceFactorsSync1!-Tuple{Array{Float64, 4}, Vararg{Vector{Float64}, 4}}" href="#BoltzmannCollisionIntegral.PhaseSpaceFactorsSync1!-Tuple{Array{Float64, 4}, Vararg{Vector{Float64}, 4}}"><code>BoltzmannCollisionIntegral.PhaseSpaceFactorsSync1!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PhaseSpaceFactorsSync1!(SMatrix,p1val,t1val,p2val,t2val)</code></pre><p>Applies phase space volume element factors for &#39;SMatrix&#39; terms in order to correctly apply &#39;SyncSymmetry&#39; corrections. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Emission/Common/SyncPhaseSpaceFactors.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.PhaseSpaceFactorsSync2!-Tuple{Array{Float64, 4}, Vector{Float64}, Vector{Float64}}" href="#BoltzmannCollisionIntegral.PhaseSpaceFactorsSync2!-Tuple{Array{Float64, 4}, Vector{Float64}, Vector{Float64}}"><code>BoltzmannCollisionIntegral.PhaseSpaceFactorsSync2!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PhaseSpaceFactorsSync2!(SMatrix,p1val,t1val)</code></pre><p>To follow &#39;PhaseSpaceFactorsSync1&#39; and &#39;SyncSymmetry&#39;. Correct phase space factors on &#39;SMatrix&#39; for use in kinetic codes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Emission/Common/SyncPhaseSpaceFactors.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.RPointLogMomentum!-Tuple{Vector{Float64}, Float64, Float64, Int64}" href="#BoltzmannCollisionIntegral.RPointLogMomentum!-Tuple{Vector{Float64}, Float64, Float64, Int64}"><code>BoltzmannCollisionIntegral.RPointLogMomentum!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RPointLogMomentum!(pu,pl,pv,num)</code></pre><p>Edits the first element of <code>pv</code> with a random real-space momentum value between <span>$10^{pl}$</span> and <span>$10^{pu}$</span>. This sample is chosen by first randomly picking a momentum bin in the range <code>1:num</code> and then uniformly sampling a momentum point in real-space (rather than log10 space) between pl and pu which are the momentum values at start and end of that bin. Sampling is done such there will be a constant number of points per momentum-space volume. As the momentum space between <span>$10^{pl}$</span> and <span>$10^{pu}$</span> it is a spherical shell hence the correct sampling is <span>$p = (U*(10^{pu})^3+(1-U)*(10^{pl})^3)^{1/3}$</span> with uniform <span>$U ∈ [0~~1]$</span>.</p><p>Assumes <span>$f(x,p,μ)=f(x,\vec{p})*(2πp^2)=const$</span> in bin, therefore momentum space volume element is <span>$\mathrm{d}p$</span> and as such uniform sampling corresponds to <span>$U*10^{u}+(1-U)*10^{l}$</span> where <span>$U$</span> is a uniform random number between 0 and 1.</p><p>If instead <span>$f(x,\vec{p})=const$</span> in bin, momentum space volume element is <span>$p^2 \mathrm{d}p$</span> and uniform sampling corresponds to <span>$(10^pu)*\sqrt[3]{U+(1-U)*10^{3pl-3pu}}$</span> where <span>$U$</span> is a uniform random number between 0 and 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Common/RandomPoints.jl#L5-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.RPointSphereBoost!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}}" href="#BoltzmannCollisionIntegral.RPointSphereBoost!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}}"><code>BoltzmannCollisionIntegral.RPointSphereBoost!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RPointSphereBoost!(βv,pvCOM)</code></pre><p>Takes the random points on the sphere generated in the centre of momentum frame <code>pCv=[ct_deboosted,ct,h]</code> and boosts them back to the lab frame using <code>βv</code> to modify the lab frame vector <code>pLv</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Common/RandomPoints.jl#L106-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.RPointSphereCosTheta!-Tuple{Vector{Float64}}" href="#BoltzmannCollisionIntegral.RPointSphereCosTheta!-Tuple{Vector{Float64}}"><code>BoltzmannCollisionIntegral.RPointSphereCosTheta!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RPointSphereTheta!()</code></pre><p>Assigns the second (cos(theta)) element of &#39;a&#39; with a randomly, uniformly sampled values of spherical angles cos(theta). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Common/RandomPoints.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.RPointSphereCosThetaPhi!-Tuple{Vector{Float64}}" href="#BoltzmannCollisionIntegral.RPointSphereCosThetaPhi!-Tuple{Vector{Float64}}"><code>BoltzmannCollisionIntegral.RPointSphereCosThetaPhi!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RPointSphereThetaPhi!()</code></pre><p>Assigns the second (cos(theta)) and third (phi) elements of &#39;a&#39; with a randomly, uniformly sampled values of spherical angles cos(theta) and phi (phi normalised by pi). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Common/RandomPoints.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.RPointSphereWeighted!-Tuple{Vector{Float64}, Float64}" href="#BoltzmannCollisionIntegral.RPointSphereWeighted!-Tuple{Vector{Float64}, Float64}"><code>BoltzmannCollisionIntegral.RPointSphereWeighted!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RPointSphereWeighted!()</code></pre><p>Assigns randomly sampled angles on the sphere (cos(theta) and phi) weighed by a doppler boosting by rapidity <code>w</code>, returning the probability <code>prob</code> for such a sample and mutating the vector <code>a</code> with elements <code>[p, cos(theta), phi, theta]</code> with angles normalised by pi. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Common/RandomPoints.jl#L186-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.RotateToCentre!-Tuple{Vector{Float64}, Float64, Float64}" href="#BoltzmannCollisionIntegral.RotateToCentre!-Tuple{Vector{Float64}, Float64, Float64}"><code>BoltzmannCollisionIntegral.RotateToCentre!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RotateToCentre(pv::Vector{Float64},t::Float64,h::Float64)

Rotates the momentum vector `pv` from the lab spherical coordinates to the spherical coordinates aligned with the centre of momentum velocity direction, The rotation angle is given by `t` theta from the lab z axis and `h` phi about the lab z axis.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/Sampling.jl#L1553-L1557">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.RotateToLab!-Tuple{Vector{Float64}, Float64, Float64}" href="#BoltzmannCollisionIntegral.RotateToLab!-Tuple{Vector{Float64}, Float64, Float64}"><code>BoltzmannCollisionIntegral.RotateToLab!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RotateToLab(pv::Vector{Float64},t::Float64,h::Float64)

Rotates the momentum vector `pv` from the centre of momentum vector aligned spherical coordinates to the spherical coordinates aligned with the lab frame. This is the inverse rotation from `RotateToCentre` The rotation angle is given by `t` theta from the lab z axis and `h` phi about the lab z axis.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/Sampling.jl#L1597-L1601">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.STMonteCarlo_MultiThread!-Tuple{Array{Float64, 9}, Array{Float64, 9}, Array{Float64, 6}, Array{UInt32, 9}, Array{UInt32, 9}, Array{UInt32, 6}, Any, Any, Function, Function, Tuple{String, String, String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64}, Int64, Int64, Float64, ProgressMeter.Progress}" href="#BoltzmannCollisionIntegral.STMonteCarlo_MultiThread!-Tuple{Array{Float64, 9}, Array{Float64, 9}, Array{Float64, 6}, Array{UInt32, 9}, Array{UInt32, 9}, Array{UInt32, 6}, Any, Any, Function, Function, Tuple{String, String, String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64}, Int64, Int64, Float64, ProgressMeter.Progress}"><code>BoltzmannCollisionIntegral.STMonteCarlo_MultiThread!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">STMonteCarlo_MultiThread!(Arrays,ArrayOfLocks,sigma,dsigmadt,UserInput)</code></pre><p><strong>Output:</strong></p><ul><li>Argument arrays SAtotal,TAtotal,SAtally,TAtally are mutated to include the results of the Monte Carlo Integration.</li></ul><p><strong>Calculation In Brief</strong></p><ul><li>Random Sample points in each of these domains<ul><li>RandomPointSphere for theta and phi (for species 1,2,3,4)</li><li>RandomPointMomentum for p ( species 1,2 only)</li></ul></li><li>Calculate T value </li><li>Take random points (u3,h3,p1,p2,u1,u2,h1,h2) and calculate valid p3 point/points </li><li>Calculate S3 value</li><li>Find position in local S and T arrays and allocated tallies and totals accordingly.</li><li>Take random points (u4,h3,p1,p2,u1,u2,h1,h2) and calculate valid p4 point/points </li><li>Calculate S4 value</li><li>Find position in local S and T arrays and allocated tallies and totals accordingly.</li><li>Update global S and T arrays with locks to prevent data races</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/MultiThread/STMonteCarlo_MultiThread.jl#L6-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.STMonteCarlo_Serial!-Tuple{Array{Float64, 9}, Array{Float64, 9}, Array{Float64, 6}, Array{UInt32, 9}, Array{UInt32, 9}, Array{UInt32, 6}, Function, Function, Tuple{String, String, String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64}, Int64, Int64}" href="#BoltzmannCollisionIntegral.STMonteCarlo_Serial!-Tuple{Array{Float64, 9}, Array{Float64, 9}, Array{Float64, 6}, Array{UInt32, 9}, Array{UInt32, 9}, Array{UInt32, 6}, Function, Function, Tuple{String, String, String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64}, Int64, Int64}"><code>BoltzmannCollisionIntegral.STMonteCarlo_Serial!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">STMonteCarlo_Serial!(Arrays,sigma,dsigmadt,UserInput)</code></pre><p>Performs Monte Carlo Integration of Gain and Loss Matrices</p><p><strong>Output:</strong></p><ul><li>Argument arrays GainTotal3,GainTotal4,GainTally3,GainTally4,LossTotal,LossTally are mutated to include the results of the Monte Carlo Integration.</li></ul><p><strong>Calculation In Brief</strong></p><ul><li>Random Sample points in each of these domains<ul><li>RandomPointSphere for theta and phi (for species 1,2,3,4)</li><li>RandomPointMomentum for p ( species 1,2 only)</li></ul></li><li>Calculate T value </li><li>Take random points (u3,h3,p1,p2,u1,u2,h1,h2) and calculate valid p3 point/points </li><li>Calculate S3 value</li><li>Find position in local Gain and Loss arrays and allocated tallies and totals accordingly.</li><li>Take random points (u4,h3,p1,p2,u1,u2,h1,h2) and calculate valid p4 point/points </li><li>Calculate S4 value</li><li>Find position in local Gain and Loss arrays and allocated tallies and totals accordingly.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Serial/STMonteCarlo_Serial.jl#L6-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.STSymmetry!-Tuple{Array{Float64, 9}, Array{Float64, 9}, Array{Float64, 6}, Float64, Float64}" href="#BoltzmannCollisionIntegral.STSymmetry!-Tuple{Array{Float64, 9}, Array{Float64, 9}, Array{Float64, 6}, Float64, Float64}"><code>BoltzmannCollisionIntegral.STSymmetry!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">STSymmetry!(SMatrix3,SMatrix4,TMatrix,u3_bounds,mu1,mu2)</code></pre><p>To follow &#39;PhaseSpaceFactors1&#39;. Physical nature of binary interaction has certain symmetries. &#39;STSymmetry&#39; uses these symmetries to improve MC sampling of &#39;SMatrix&#39; and &#39;TMatrix&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/MomentumSpaceFactors.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.SValue3-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64, Float64, Function, Vararg{Float64, 5}}" href="#BoltzmannCollisionIntegral.SValue3-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64, Float64, Function, Vararg{Float64, 5}}"><code>BoltzmannCollisionIntegral.SValue3</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SValue3(p3v,p1v,p2v,dsigmadt,mu1,mu2,mu3)</code></pre><p>Returns <code>Sval</code> from MC integration based on initial momentum states <code>p1v</code> and <code>p2v</code> and final state <code>p3v</code> and differential cross section <code>dsigmadt</code> based on particle selection 12-&gt;34. </p><p class="math-container">\[S_\text{val}=\frac{\mathrm{d}\sigma_{12|34}}{\mathrm{d}t}\frac{\mathcal{F}_{12}^2}{\pi\left|p^0_3(p_1\cos\Theta_{31}+p_2\cos\Theta_{32})-p_3(p^0_1+p^0_2)\right|}rac{p_3^2}{p^0_1p^0_2}.\]</p><p>Assumes f(x,p,u,ϕ)=f(x,vec{p})/p^2=constant over bin</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/STValue.jl#L105-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.SValue4-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64, Float64, Function, Vararg{Float64, 5}}" href="#BoltzmannCollisionIntegral.SValue4-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64, Float64, Function, Vararg{Float64, 5}}"><code>BoltzmannCollisionIntegral.SValue4</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SValue4(p3v,p1v,p2v,dsigmadt,mu1,mu2,mu3,mu4)</code></pre><p>Returns <code>Sval</code> from MC integration based on initial momentum states <code>p1v</code> and <code>p2v</code> and final state <code>p4v</code> and differential cross section <code>dsigmadt</code> based on particle selection 12-&gt;34.   Assumes f(x,p,μ)=constant over bin</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/STValue.jl#L232-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.SpectraEvaluateMultiThread-Tuple{Tuple{Tuple{String, String, String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64}, Int64, Int64, Int64, String, String}}" href="#BoltzmannCollisionIntegral.SpectraEvaluateMultiThread-Tuple{Tuple{Tuple{String, String, String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64}, Int64, Int64, Int64, String, String}}"><code>BoltzmannCollisionIntegral.SpectraEvaluateMultiThread</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpectraEvaluateMultiThread(userInputMultiThread)</code></pre><p>Function to run the Monte Carlo integration of the S and T arrays in a multi-threaded environment. The function will run the Monte Carlo integration in parallel across the number of threads specified in the global variable nThreads. The function will then calculate the S and T matrices and save the results to a file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/MultiThread/STIntegration_MultiThread.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.SpectraEvaluateSerial-Tuple{Tuple{Tuple{String, String, String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64}, Int64, Int64, String, String}}" href="#BoltzmannCollisionIntegral.SpectraEvaluateSerial-Tuple{Tuple{Tuple{String, String, String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, String, Int64}, Int64, Int64, String, String}}"><code>BoltzmannCollisionIntegral.SpectraEvaluateSerial</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpectraEvaluateSerial(userInputSerial)</code></pre><p>Function to run the Monte Carlo integration of the S and T arrays in a serial environment. The function will run the Monte Carlo integration in serial and then calculate the S and T matrices and save the results to a file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Serial/STIntegration_Serial.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.SyncEvaluateMultiThread-Tuple{Tuple{Tuple{String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64}, Int64, Int64, Int64, String, String}}" href="#BoltzmannCollisionIntegral.SyncEvaluateMultiThread-Tuple{Tuple{Tuple{String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64}, Int64, Int64, Int64, String, String}}"><code>BoltzmannCollisionIntegral.SyncEvaluateMultiThread</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SyncEvaluateMultiThread!(userSyncInputMultiThread)</code></pre><p>Function to run the Monte Carlo integration of the S array in a serial enviroment. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Emission/MultiThread/SyncIntegration_MultiThread.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.SyncEvaluateSerial-Tuple{Tuple{Tuple{String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64}, Int64, Int64, String, String}}" href="#BoltzmannCollisionIntegral.SyncEvaluateSerial-Tuple{Tuple{Tuple{String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64}, Int64, Int64, String, String}}"><code>BoltzmannCollisionIntegral.SyncEvaluateSerial</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SyncEvaluateSerial!(userSyncInputSerial)</code></pre><p>Function to run the Monte Carlo integration of the S array in a serial environment. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Emission/Serial/SyncIntegration_Serial.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.SyncKernel-NTuple{5, Any}" href="#BoltzmannCollisionIntegral.SyncKernel-NTuple{5, Any}"><code>BoltzmannCollisionIntegral.SyncKernel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SyncKernel(p1v,p2v,m2,z2,B)</code></pre><p>Returns the emission rate for a single photon <span>$p1v$</span> state emitted by a charged particle in state <span>$p2v$</span> with charge <span>$z2$</span> relative to the fundamental charge and mass <span>$m2$</span> relative to the mass of the electron, in a uniform magnetic field <span>$B$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Emission/Common/SynchrotronKernel.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.SyncMonteCarloAxi_MultiThread!-Tuple{Array{Float64, 4}, Array{UInt32, 4}, Any, Tuple{String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64}, Int64, Int64, Int64, ProgressMeter.Progress}" href="#BoltzmannCollisionIntegral.SyncMonteCarloAxi_MultiThread!-Tuple{Array{Float64, 4}, Array{UInt32, 4}, Any, Tuple{String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64}, Int64, Int64, Int64, ProgressMeter.Progress}"><code>BoltzmannCollisionIntegral.SyncMonteCarloAxi_MultiThread!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SyncMonteCarloAxi_MultiThread!(SAtotal,SAtally,pMax,tMinMax,Parameters,numSiter)</code></pre><p><strong>Arguments</strong></p><ul><li><code>SAtotal::Array{Float64,4}</code> : Array of stored integration totals for S matrix for 2+B-&gt;2+B+1 interaction</li><li><code>SAtally::Array{UInt32,4}</code> : Array of stored integration tallies for S matrix for 2+B-&gt;2+B+1 interaction</li><li><code>pMax::Array{Float64,3}</code> : Array of maximum momentum values for species 2</li><li><code>tMinMax::Array{Float64,3}</code> : Array of minimum and maximum theta values for species 2</li><li><code>Parameters::Tuple{Float64,Float64,Float64,Int64,Float64,Float64,Int64,Int64,Int64}</code> : Tuple of parameters for the interaction</li><li><code>numSiter::Int64</code> : Number of S iterations</li></ul><p><strong>Output:</strong></p><ul><li>Argument arrays SAtotal,SAtally are mutated to include the results of the Monte Carlo Integration.</li></ul><p><strong>Calculation In Brief</strong></p><ul><li>Random Sample points in each of these domains<ul><li>RandomPointSphere for theta (for species 1,2)</li><li>RandomPointMomentum for p ( species 1,2)</li></ul></li><li>Take random points (p1,p2,t1,t2) and calculate Synchrotron emissivity</li><li>Find position in S arrays and allocated tallies and totals accordingly.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Emission/MultiThread/SyncMonteCarlo_MultiThread.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.SyncMonteCarloAxi_Serial!-Tuple{Array{Float64, 4}, Array{UInt32, 4}, Tuple{String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64}, Int64, Int64}" href="#BoltzmannCollisionIntegral.SyncMonteCarloAxi_Serial!-Tuple{Array{Float64, 4}, Array{UInt32, 4}, Tuple{String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64}, Int64, Int64}"><code>BoltzmannCollisionIntegral.SyncMonteCarloAxi_Serial!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SyncMonteCarloAxi_Serial!(SAtotal,SAtally,pMax,tMinMax,Parameters,numSiter)</code></pre><p><strong>Arguments</strong></p><ul><li><code>SAtotal::Array{Float64,4}</code> : Array of stored integration totals for S matrix for 2+B-&gt;2+B+1 interaction</li><li><code>SAtally::Array{UInt32,4}</code> : Array of stored integration tallies for S matrix for 2+B-&gt;2+B+1 interaction</li><li><code>pMax::Array{Float64,3}</code> : Array of maximum momentum values for species 2</li><li><code>tMinMax::Array{Float64,3}</code> : Array of minimum and maximum theta values for species 2</li><li><code>Parameters::Tuple{Float64,Float64,Float64,Int64,Float64,Float64,Int64,Int64,Int64}</code> : Tuple of parameters for the interaction</li><li><code>numSiter::Int64</code> : Number of S iterations</li></ul><p><strong>Output:</strong></p><ul><li>Argument arrays SAtotal,SAtally are mutated to include the results of the Monte Carlo Integration.</li></ul><p><strong>Calculation In Brief</strong></p><ul><li>Random Sample points in each of these domains<ul><li>RandomPointSphere for theta (for species 1,2)</li><li>RandomPointMomentum for p ( species 1,2)</li></ul></li><li>Take random points (p1,p2,t1,t2) and calculate Synchrotron emissivity</li><li>Find position in S arrays and allocated tallies and totals accordingly.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Emission/Serial/SyncMonteCarlo_Serial.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.SyncSymmetry!-Tuple{Array{Float64, 4}}" href="#BoltzmannCollisionIntegral.SyncSymmetry!-Tuple{Array{Float64, 4}}"><code>BoltzmannCollisionIntegral.SyncSymmetry!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SyncSymmetry!(SMatrix)</code></pre><p>To follow &#39;PhaseSpaceFactorsSync1&#39;. Synchrotron emission has a symmetry with respect to cos(theta) -&gt; -cos(theta) for both initial particle and photon momenta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Emission/Common/SyncPhaseSpaceFactors.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.TValue-Tuple{Vector{Float64}, Vector{Float64}, Function, Vararg{Float64, 4}}" href="#BoltzmannCollisionIntegral.TValue-Tuple{Vector{Float64}, Vector{Float64}, Function, Vararg{Float64, 4}}"><code>BoltzmannCollisionIntegral.TValue</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TValue(p1v,p2v,sigma,mu1,mu2)</code></pre><p>returns <code>Tval</code> with its Tval from MC integration based on initial momentum states <code>p1v</code> and <code>p2v</code> and cross section <code>sigma</code> based on particle selection.</p><p class="math-container">\[T_\text{val} = \frac{1}{p^0_1p^0_2}\sigma(s)F_12(s)\]</p><p>If initial state fails <code>sCheck</code>, i.e. cannot generate a physical output state, Tval is set to 0e0.  Assumes f(x,p,u,ϕ)=f(x,vec{p})/p^2=constant over bin</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/STValue.jl#L26-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.ThetaValue-Tuple{Vector{Float64}, Vector{Float64}}" href="#BoltzmannCollisionIntegral.ThetaValue-Tuple{Vector{Float64}, Vector{Float64}}"><code>BoltzmannCollisionIntegral.ThetaValue</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CosThetaValue(p1v,p2v)</code></pre><p>Returns the cosine of the angle between two momentum vectors <code>p1v</code> and <code>p2v</code> of format [p,cos(theta),phi/pi,theta/pi]. To aid in floating point precision, 1 is subtracted from the returned cosine value. i.e. CosTheta12m1 = cos(Theta12) - 1.0. This is done as it is often the case that two momentum states are very close together.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/STValue.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.UniformSampling!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Function, AbstractArray{Float64, 3}, AbstractArray{Float64, 3}, AbstractArray{UInt32, 3}, AbstractArray{UInt32, 3}, Tuple{Float64, Float64, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Float64, Float64, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Vararg{Float64, 4}}}" href="#BoltzmannCollisionIntegral.UniformSampling!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Function, AbstractArray{Float64, 3}, AbstractArray{Float64, 3}, AbstractArray{UInt32, 3}, AbstractArray{UInt32, 3}, Tuple{Float64, Float64, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Float64, Float64, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Int64, BoltzmannCollisionIntegral.GridType, Vararg{Float64, 4}}}"><code>BoltzmannCollisionIntegral.UniformSampling!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UniformSampling!()</code></pre><p>Uniform MC sampling of outgoing momentum states in the un-boosted Lab frame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/Sampling.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.Weight!-Tuple{Vector{Float64}, Float64, Float64}" href="#BoltzmannCollisionIntegral.Weight!-Tuple{Vector{Float64}, Float64, Float64}"><code>BoltzmannCollisionIntegral.Weight!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Weight!(pv::Vector{Float64},w::Float64)</code></pre><p>Computes the doppler factor aka cosine angle jacobian for a particle of mass <code>m</code> between the CM frame and lab frame, for a boost with rapididty <code>w</code> in the z direction (w must be +ve). The result is stored in the fifth entry of the vector <code>pv</code>. Which is expected to have components [p,cos(theta),phi,theta,doppler].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/Sampling.jl#L1413-L1417">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.WeightedAverageGain!-Tuple{Array{Float64, 9}, Array{Float64, 9}, AbstractArray{UInt32, 9}, Array{UInt32, 9}, Array{Float64, 9}, Array{Float64, 9}, AbstractArray{UInt32, 9}, Array{UInt32, 9}}" href="#BoltzmannCollisionIntegral.WeightedAverageGain!-Tuple{Array{Float64, 9}, Array{Float64, 9}, AbstractArray{UInt32, 9}, Array{UInt32, 9}, Array{Float64, 9}, Array{Float64, 9}, AbstractArray{UInt32, 9}, Array{UInt32, 9}}"><code>BoltzmannCollisionIntegral.WeightedAverageGain!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WeightedAverage!(GainMatrix3,OldGainMatrix3,GainTally3_K,OldGainTally3_K,GainMatrix4,OldGainMatrix4,GainTally4_K,OldGainTally4_K)</code></pre><p>Computes the integral estimate by weighted average of the old and new gain matrices. Mutating the old gain and tally terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/Sampling.jl#L1621-L1625">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.WeightedAverageLoss!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{UInt32, 6}, Array{UInt32, 6}}" href="#BoltzmannCollisionIntegral.WeightedAverageLoss!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{UInt32, 6}, Array{UInt32, 6}}"><code>BoltzmannCollisionIntegral.WeightedAverageLoss!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WeightedAverageLoss!(LossMatrix,OldLossMatrix,LossTally,OldLossTally)</code></pre><p>Computes the integral estimate by weighted average of the old and new gain matrices. Mutating the old gain and tally terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/Sampling.jl#L1641-L1645">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.WeightedFactors-Tuple{Vector{Float64}, Vector{Float64}, Float64, Float64, Float64}" href="#BoltzmannCollisionIntegral.WeightedFactors-Tuple{Vector{Float64}, Vector{Float64}, Float64, Float64, Float64}"><code>BoltzmannCollisionIntegral.WeightedFactors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WeightedFactors!()</code></pre><p>Returns the weighting rapidity <code>w</code> and the direction an angles <code>t</code> and <code>h</code> for rotations on a sphere.  Weighting rapidity can be scaled by <code>scale</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Common/RandomPoints.jl#L158-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.betaVec!-Tuple{Vector{Float64}, Vararg{Any, 4}}" href="#BoltzmannCollisionIntegral.betaVec!-Tuple{Vector{Float64}, Vararg{Any, 4}}"><code>BoltzmannCollisionIntegral.betaVec!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">betaVec!(βv,p1v,p2v)</code></pre><p>Mutates the components of the centre of momentum velocity vector <code>βv</code> with components <code>[β,u,phi,γ,γβ] in terms of the incident state vectors</code>p1v<code>and</code>p1v`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Common/RandomPoints.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.bounds-Union{Tuple{T}, Tuple{T, T, Int64, String}} where T&lt;:Union{Float32, Float64}" href="#BoltzmannCollisionIntegral.bounds-Union{Tuple{T}, Tuple{T, T, Int64, String}} where T&lt;:Union{Float32, Float64}"><code>BoltzmannCollisionIntegral.bounds</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bounds(up_bound,low_bound,num,spacing)</code></pre><p>Returns a <code>num+1</code> long <code>Vector{Float}</code> of grid bounds. These grid bounds can spaced either by      - linear spacing: <code>spacing = &quot;u&quot;</code>     - log10 spacing: <code>spacing = &quot;l&quot;</code>     - binary (1/2^n) spacing: <code>spacing = &quot;b&quot;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/UsefulGridValueFunctions.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.bounds_p-Union{Tuple{T}, Tuple{T, T, Int64}} where T&lt;:Union{Float32, Float64}" href="#BoltzmannCollisionIntegral.bounds_p-Union{Tuple{T}, Tuple{T, T, Int64}} where T&lt;:Union{Float32, Float64}"><code>BoltzmannCollisionIntegral.bounds_p</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bounds_p(pl,pu,nump)</code></pre><p>Returns a <code>nump+1</code> long <code>Vector{Float}</code> of p-space grid bounds NOT in Log10 space.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bounds_p(-5e0,4e0,9)
10-element Vector{Float64}:
 1.0e-5
 1.0e-4
 1.0e-3
 0.01
 0.1
 1.0
 10.0
 100.0
 1000.0
 10000.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/UsefulGridValueFunctions.jl#L26-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.bounds_t-Tuple{Int64}" href="#BoltzmannCollisionIntegral.bounds_t-Tuple{Int64}"><code>BoltzmannCollisionIntegral.bounds_t</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bounds_t(numt)</code></pre><p>Returns a <code>numt+1</code> long <code>Vector{Float}</code> of theta-space grid bounds in terms of cos(theta). Upper and lower bounds [tl tu] are defined as CONST in Init.jl as [-1 1], type returned is that of tl, tu.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bounds_t(8)
9-element Vector{Float64}:
 -1.0
 -0.75
 -0.5
 -0.25
  0.0
  0.25
  0.5
  0.75
  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/UsefulGridValueFunctions.jl#L52-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.deltaEVector-Union{Tuple{T}, Tuple{Vector{T}, T}} where T&lt;:Union{Float32, Float64}" href="#BoltzmannCollisionIntegral.deltaEVector-Union{Tuple{T}, Tuple{Vector{T}, T}} where T&lt;:Union{Float32, Float64}"><code>BoltzmannCollisionIntegral.deltaEVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deltaEVector(pr,mu)</code></pre><p>Inputs a <code>num+1</code> long <code>Vector{Float}</code> of p grid boundaries and the particle <code>mu</code> value (normalised mass) and returns a <code>num</code> long <code>Vector{Float}</code> of average energy values per grid cell.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; deltaEVector([1.0e0, 10.0e0, 100.0e0, 1000.0e0], 1.0e0)
3-element Vector{Float64}:
 50.600693
 4951.15
 495001.16</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/UsefulGridValueFunctions.jl#L136-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.deltaEkinVector-Union{Tuple{T}, Tuple{Vector{T}, T}} where T&lt;:Union{Float32, Float64}" href="#BoltzmannCollisionIntegral.deltaEkinVector-Union{Tuple{T}, Tuple{Vector{T}, T}} where T&lt;:Union{Float32, Float64}"><code>BoltzmannCollisionIntegral.deltaEkinVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deltaEkinVector(pr,mu)</code></pre><p>Inputs a <code>num+1</code> long <code>Vector{Float}</code> of p grid boundaries and the particle <code>mu</code> value (normalised mass) and returns a <code>num</code> long <code>Vector{Float}</code> of average kinetic energy values per grid cell.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; deltaEkinVector([1.0e0, 10.0e0, 100.0e0, 1000.0e0], 1.0e0)
3-element Vector{Float64}:
     46.10069600605712
   4906.1506753523645
 494551.15128635924</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/UsefulGridValueFunctions.jl#L179-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.deltaVector-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64}" href="#BoltzmannCollisionIntegral.deltaVector-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64}"><code>BoltzmannCollisionIntegral.deltaVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deltaVector(valr)</code></pre><p>Inputs a <code>num+1</code> long <code>Vector{Float}</code> quantity values (domain bounds) and returns a <code>num</code> long <code>Vector{Float}</code> of differences (domain widths).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; deltaVector([1.0e0, 10.0e0, 100.0e0, 1000.0e0])
3-element Vector{Float64}:
 9.0
 90.0
 900.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/UsefulGridValueFunctions.jl#L80-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.dsigmadt_ElePhoElePho-NTuple{6, Float64}" href="#BoltzmannCollisionIntegral.dsigmadt_ElePhoElePho-NTuple{6, Float64}"><code>BoltzmannCollisionIntegral.dsigmadt_ElePhoElePho</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dsigmadt_ElePhoElePho(sSmol,sBig,tSmol,tBig,uSmol,uBig)</code></pre><p>returns the differential cross section for electron-photon scattering (Compton) scattering. Berestetskii 1982 (86.6). Masses and momenta are normalised by the rest mass of the electron <span>$m_{\text{Ele}}$</span> and the cross section is normalised by <span>$σ_T$</span>.</p><p class="math-container">\[\frac{d\sigma_{e\gamma\rightarrow e\gamma}}{dt}(s,t)=\frac{3}{(s-1)^2}\left[\left(\frac{1}{s-1}+\frac{1}{u-1}\right)^2+\left(\frac{1}{s-1}+\frac{1}{u-1}\right)-\frac{1}{4}\left(\frac{s-1}{u-1}+\frac{u-1}{s-1}\right)\right]\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : <span>$s - sBig$</span></li><li><code>sBig::Float64</code> : <span>$(m_1+m_2)^2 = 1 ∴ s = sSmol + 1$</span></li><li><code>tSmol::Float64</code> : <span>$t - tBig$</span></li><li><code>tBig::Float64</code> : <span>$(m_3-m_1)^2 = 0 ∴ t = tSmol$</span></li><li><code>uSmol::Float64</code> : <span>$u - uBig$</span></li><li><code>uBig::Float64</code> : <span>$(m_2-m_3)^2 = 1 ∴ u = uSmol + 1$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/DifferentialCrossSectionFunctions.jl#L173-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho-NTuple{6, Float64}" href="#BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho-NTuple{6, Float64}"><code>BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dsigmadt_ElePosPhoPho(sSmol,sBig,tSmol,tBig,uSmol,uBig)</code></pre><p>returns the differential cross section for electron positron annihilation to two photons. Berestetskii 1982 (88.4). Masses and momenta are normalised by the rest mass of the electron <span>$m_{\text{Ele}}$</span> and the cross section is normalised by <span>$σ_T$</span>.</p><p class="math-container">\[\frac{dσ_{e^+e^-\rightarrow\gamma\gamma}}{dt} = -\frac{3}{s(s-4)}\left(\left(\frac{1}{t-1}+\frac{1}{u-1}\right)^2+\left(\frac{1}{t-1}+\frac{1}{u-1}\right)-\frac{1}{4}\left(\frac{t-1}{u-1}+\frac{u-1}{t-1}\right)\right)\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : <span>$s - sBig$</span></li><li><code>sBig::Float64</code> : <span>$(m_1+m_2)^2 = 4 ∴ s = sSmol + 4$</span></li><li><code>tSmol::Float64</code> : <span>$t - tBig$</span></li><li><code>tBig::Float64</code> : <span>$(m_3-m_1)^2 = 1 ∴ t = tSmol + 1$</span></li><li><code>uSmol::Float64</code> : <span>$u - uBig$</span></li><li><code>uBig::Float64</code> : <span>$(m2-m3)^2 = 1 ∴ u = uSmol + 1$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/DifferentialCrossSectionFunctions.jl#L63-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos-NTuple{6, Float64}" href="#BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos-NTuple{6, Float64}"><code>BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dsigmadt_PhoPhoElePos(sSmol,sBig,tSmol,tBig,uSmol,uBig)</code></pre><p>returns the differential cross section for photon-photon annihilation to electron-positron pair. (Inverse proceess of electron positron annihilation to two photons). Masses and momenta are normalised by the rest mass of the electron <span>$m_{\text{Ele}}$</span> and the cross section is normalised by <span>$σ_T$</span>.</p><p class="math-container">\[\frac{dσ_{\gamma\gamma\rightarrow e^+e^-}}{dt} = -\frac{3}{s^2}\left(\left(\frac{1}{t-1}+\frac{1}{u-1}\right)^2+\left(\frac{1}{t-1}+\frac{1}{u-1}\right)-\frac{1}{4}\left(\frac{t-1}{u-1}+\frac{u-1}{t-1}\right)\right)\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : <span>$s - sBig$</span></li><li><code>sBig::Float64</code> : <span>$(m_1+m_2)^2 = 0 ∴ s = sSmol$</span></li><li><code>tSmol::Float64</code> : <span>$t - tBig$</span></li><li><code>tBig::Float64</code> : <span>$(m_3-m_1)^2 = 1 ∴ t = tSmol + 1$</span></li><li><code>uSmol::Float64</code> : <span>$u - uBig$</span></li><li><code>uBig::Float64</code> : <span>$(m_2-m_3)^2 = 1 ∴ u = uSmol + 1$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/DifferentialCrossSectionFunctions.jl#L119-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph-NTuple{6, Float64}" href="#BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph-NTuple{6, Float64}"><code>BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dsigmadt_SphSphSphSph(sSmol,sBig,tSmol,tBig,uSmol,uBig)</code></pre><p>returns the differential cross section for the binary interaction of hard spheres with normalised masses <span>$m_1,m_2,m_3,m_4=m_{\text{Sph}}$</span>. Normalised by <span>$πR_{Sph}^2$</span>.</p><p class="math-container">\[\frac{dσ}{dt} = \frac{1}{s-4m_{\text{Sph}}^2}\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : <span>$s - sBig$</span></li><li><code>sBig::Float64</code> : <span>$(m_1+m_2)^2=4m_{\text{Sph}}^2$</span></li><li><code>tSmol::Float64</code> : <span>$t - tBig$</span></li><li><code>tBig::Float64</code> : <span>$(m_3-m_1)^2=0$</span></li><li><code>uSmol::Float64</code> : <span>$u - uBig$</span></li><li><code>uBig::Float64</code> : <span>$(m_2-m_3)^2=0$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/DifferentialCrossSectionFunctions.jl#L9-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.fload_All-Tuple{String, String}" href="#BoltzmannCollisionIntegral.fload_All-Tuple{String, String}"><code>BoltzmannCollisionIntegral.fload_All</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fload_All(fileLocation,fileName)</code></pre><p>Loads all the data stored in <code>fileName</code> stored at <code>fileLocation</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">    (Parameters,SAtot3,SAtot4,TAtot,SAtal3,SAtal4,TAtal,SMatrix3,SMatrix4,TMatrix1,TMatrix2,p3Max,p4Max,u3MinMax,u4MinMax,SConv3,SConv4,TConv) = fload_All(fileLocation,fileName);</code></pre><p>Returns a tuple of the data stored in the file. The fields are as follows:</p><ul><li><code>Parameters</code> : A tuple of the parameters used in the evaluation.</li><li><code>Stot3</code> : A 6D matrix totalling all the emission spectrum values sampled for 12-&gt;34 interaction.</li><li><code>Stot4</code> : A 6D matrix totalling all the emission spectrum values sampled for 12-&gt;43 interaction.</li><li><code>Ttot</code> : A 4D matrix totalling all the absorption spectrum values sampled.</li><li><code>Stal3</code> : A 5D matrix of tallies of the number of emission spectrum values sampled for 12-&gt;34 interaction.</li><li><code>Stal4</code> : A 5D matrix of tallies of the number of emission spectrum values sampled for 12-&gt;43 interaction.</li><li><code>Ttal</code> : A 4D matrix of tallies of the number of absorption spectrum values sampled.</li><li><code>SMatrix3</code> : A 6D matrix of the emission spectrum for 12-&gt;34 interaction.</li><li><code>SMatrix4</code> : A 6D matrix of the emission spectrum for 12-&gt;43 interaction.</li><li><code>TMatrix1</code> : A 4D matrix of the absorption spectrum for 12-&gt;34 interaction.</li><li><code>TMatrix2</code> : A 4D matrix of the absorption spectrum for 21-&gt;34 interaction i.e. by permutation of TMatrix1 and correct application of phase space factors if species 1 != species 2.</li><li><code>p3Max</code> : The maximum value of the momentum space variable p3 sampled for each bin. (Useful for correcting numerical diffusion)</li><li><code>u3MinMax</code> : The minimum and maximum values of the momentum space variable t3 sampled for each bin. (Useful for correcting numerical diffusion)</li><li><code>p4Max</code> : The maximum value of the momentum space variable p4 sampled for each bin. (Useful for correcting numerical diffusion)</li><li><code>u4MinMax</code> : The minimum and maximum values of the momentum space variable t4 sampled for each bin. (Useful for correcting numerical diffusion)</li><li><code>SConv3</code> : A 6D matrix of the convergence of the emission spectrum compared to the previous run with given <code>Parameters</code> for 12-&gt;34 interaction.</li><li><code>SConv4</code> : A 6D matrix of the convergence of the emission spectrum compared to the previous run with given <code>Parameters</code> for 12-&gt;43 interaction.</li><li><code>TConv</code> : A 4D matrix of the convergence of the absorption spectrum compared to the previous run with given <code>Parameters</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/DataReading.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.fload_All_Sync-Tuple{String, String}" href="#BoltzmannCollisionIntegral.fload_All_Sync-Tuple{String, String}"><code>BoltzmannCollisionIntegral.fload_All_Sync</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fload_All_Sync(fileLocation,fileName)</code></pre><p>Loads all the data stored in <code>fileName</code> stored at <code>fileLocation</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">    (Run_Parameters,SAtot,SAtal,SMatrix,#=pMax,tMinMax,=#SConv) = fload_All_Sync(fileLocation,fileName);</code></pre><p>Returns a tuple of the data stored in the file. The fields are as follows:</p><ul><li><code>Run_Parameters</code> : A tuple of the parameters used in the evaluation.</li><li><code>Stot</code> : A 4D matrix totalling all the synchrotron emission spectrum values</li><li><code>Stal</code> : A 4D matrix of tallies of the number of synchrotron emission spectrum values sampled</li><li><code>SMatrix</code> : A 4D matrix of the synchrotron emission spectrum.</li><li><code>pMax</code> : The maximum value of the momentum space variable p1 (photon mommentum) sampled for each bin. (Useful for correcting numerical diffusion)</li><li><code>tMinMax</code> : The minimum and maximum values of the momentum space variable t1 sampled for each bin. (Useful for correcting numerical diffusion)</li><li><code>SConv</code> : A 4D matrix of the convergence of the synchrotron emission spectrum compared to the previous run with given <code>Run_Parameters</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Emission/Common/SyncDataReading.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.fload_Matrix-Tuple{String, String}" href="#BoltzmannCollisionIntegral.fload_Matrix-Tuple{String, String}"><code>BoltzmannCollisionIntegral.fload_Matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fload_Matrix(fileLocation,fileName)</code></pre><p>Loads just the Gain and Loss Matrices stored in <code>fileName</code> stored at <code>fileLocation</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">    Matrices = fload_All(fileLocation,fileName);</code></pre><p>Returns a tuple of the data stored in the file. The fields are as follows:</p><ul><li><code>Parameters</code> : A tuple of the parameters used in the evaluation.</li><li><code>GainMatrix3</code> : A 9D matrix of the emission spectrum for 12-&gt;34 interaction.</li><li><code>GainMatrix4</code> : A 9D matrix of the emission spectrum for 12-&gt;43 interaction.</li><li><code>LossMatrix1</code> : A 6D matrix of the absorption spectrum for 12-&gt;34 interaction.</li><li><code>LossMatrix2</code> : A 6D matrix of the absorption spectrum for 21-&gt;34 interaction.</li></ul><p>If initial or final particles are identical then only one of the SMatrices or TMatrices will be returned for that state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/DataReading.jl#L82-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.fload_Matrix_ISO-Tuple{String, String}" href="#BoltzmannCollisionIntegral.fload_Matrix_ISO-Tuple{String, String}"><code>BoltzmannCollisionIntegral.fload_Matrix_ISO</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fload_Matrix_ISO(fileLocation,fileName)</code></pre><p>Loads just the S and T Matrices stored in <code>fileName</code> stored at <code>fileLocation</code> first converting them to an isotropic form by summing over angles. (The dimensions of the matrices stay the same i.e. 6D-&gt;6D with three dimensions having a size of 1)</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">    Matrices = fload_All_ISO(fileLocation,fileName);</code></pre><p>Returns a tuple of the data stored in the file. The fields are as follows:</p><ul><li><code>Parameters</code> : A tuple of the parameters used in the evaluation.</li><li><code>SMatrix3</code> : A 6D matrix of the emission spectrum for 12-&gt;34 interaction.</li><li><code>SMatrix4</code> : A 6D matrix of the emission spectrum for 12-&gt;43 interaction.</li><li><code>TMatrix1</code> : A 4D matrix of the absorption spectrum for 12-&gt;34 interaction.</li><li><code>TMatrix2</code> : A 4D matrix of the absorption spectrum for 21-&gt;34 interaction.</li></ul><p>If initial or final particles are identical then only one of the SMatrices or TMatrices will be returned for that state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/DataReading.jl#L127-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.fload_Matrix_Sync-Tuple{String, String}" href="#BoltzmannCollisionIntegral.fload_Matrix_Sync-Tuple{String, String}"><code>BoltzmannCollisionIntegral.fload_Matrix_Sync</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fload_Matrix_Sync(fileLocation,fileName)</code></pre><p>Loads just the S and T Matrices stored in <code>fileName</code> stored at <code>fileLocation</code>. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">    Matrices = fload_Matrix_Sync(fileLocation,fileName);</code></pre><p>Returns a tuple of the data stored in the file. The fields are as follows:</p><ul><li><code>SMatrix</code> : A 4D matrix of the emission spectrum for Synchrotron.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Emission/Common/SyncDataReading.jl#L44-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.fload_Matrix_SyncISO-Tuple{String, String}" href="#BoltzmannCollisionIntegral.fload_Matrix_SyncISO-Tuple{String, String}"><code>BoltzmannCollisionIntegral.fload_Matrix_SyncISO</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fload_Matrix_SyncISO(fileLocation,fileName)</code></pre><p>Loads just the S and T Matrices stored in <code>fileName</code> stored at <code>fileLocation</code> first converting them to an isotropic form by summing over angles. (The dimensions of the matrices stay the same i.e. 6D-&gt;6D with three dimensions having a size of 1)</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">    Matrices = fload_Matrix_SyncISO(fileLocation,fileName);</code></pre><p>Returns a tuple of the data stored in the file. The fields are as follows:</p><ul><li><code>SMatrix</code> : A 4D matrix of the emission spectrum for Synchrotron.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Emission/Common/SyncDataReading.jl#L75-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.location-Tuple{Float64, Float64, Int64, Float64, String}" href="#BoltzmannCollisionIntegral.location-Tuple{Float64, Float64, Int64, Float64, String}"><code>BoltzmannCollisionIntegral.location</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">location(low_bound,up_bound,num,val,spacing)</code></pre><p>Returns the index of the bin in which &#39;val&#39; is contained based the grid bounds of that variable with &#39;num&#39; bins.</p><p>Implemented grid spacing types are:     - uniform spacing: <code>spacing = &quot;u&quot;</code>     - log10 spacing: <code>spacing = &quot;l&quot;</code>         - up and low bounds should be supplied as log10 values     - binary (1/2^n) spacing: <code>spacing = &quot;b&quot;</code>          - binary spacing is used for u=cos(theta) grids and therefore bounds should always be [-1 1] and num must be odd!</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; location(0e0,10e0,9,2e0,&quot;u&quot;)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Common/Location.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.location_p-Tuple{Float64, Float64, Int64, Float64}" href="#BoltzmannCollisionIntegral.location_p-Tuple{Float64, Float64, Int64, Float64}"><code>BoltzmannCollisionIntegral.location_p</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">location_p(u,l,num,val)</code></pre><p>Returns the index of the momentum bin in which &#39;val&#39; is contatined based on the &#39;num&#39; of bins and their &#39;u&#39; upper and &#39;l&#39; lower bound including overflow and underflow possibilities. Overflow are assigned to num+1 while underflow are assigned to lowest bin i.e. 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; location_p(10e0,1e0,9,2e0)
2
julia&gt; location_p(10e0,1e0,9,11e0) # overflow
10
julia&gt; location_p(10e0,1e0,9,0.5e0) # underflow
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Common/Location.jl#L85-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.location_t-Tuple{Int64, Float64}" href="#BoltzmannCollisionIntegral.location_t-Tuple{Int64, Float64}"><code>BoltzmannCollisionIntegral.location_t</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">location_t(numt,val)</code></pre><p>Returns the index of the bin in which the costheta &#39;val&#39; is contatined based on the &#39;numt&#39; of bins. Bounds [tl tu] are defined as CONST in Init.jl</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; location_t(8,0.5e0)
6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Common/Location.jl#L69-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.meanVector-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64}" href="#BoltzmannCollisionIntegral.meanVector-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64}"><code>BoltzmannCollisionIntegral.meanVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">meanVector(valr)</code></pre><p>Inputs a <code>num+1</code> long <code>Vector{Float}</code> of domain bounds and returns a <code>num</code> long <code>Vector{Float}</code> of mean value in domain range.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; meanVector([1.0e0, 10.0e0, 100.0e0, 1000.0e0])
3-element Vector{Float64}:
 5.5
 55.0
 550.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/UsefulGridValueFunctions.jl#L108-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.pVector!-NTuple{4, Vector{Float64}}" href="#BoltzmannCollisionIntegral.pVector!-NTuple{4, Vector{Float64}}"><code>BoltzmannCollisionIntegral.pVector!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pVector!(p4v,p3v,p1v,p2v)</code></pre><p>Returns the p vector (in standard form [p,cos(theta),phi/pi]) of the non-sampled outgoing state, given the p1, p2 and p3 or p4 vectors using conservation of momentum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/Momentum3Values.jl#L536-L540">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.pdfBoost-Tuple{Vector{Float64}, Float64}" href="#BoltzmannCollisionIntegral.pdfBoost-Tuple{Vector{Float64}, Float64}"><code>BoltzmannCollisionIntegral.pdfBoost</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pdfBoost(βv,pCv)</code></pre><p>returns the probability of sampling a point given by <code>pCv</code> dependent on the boost <code>βv</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Common/RandomPoints.jl#L135-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.sCheck-NTuple{6, Float64}" href="#BoltzmannCollisionIntegral.sCheck-NTuple{6, Float64}"><code>BoltzmannCollisionIntegral.sCheck</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sCheck(sSmol,sBig,mu3,mu4)</code></pre><p>Returns &#39;true&#39; if &#39;s&#39; mandelstram generated from inital system state can generate a physical output state. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/MandelstramChecks.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.sigma_ElePhoElePho-Tuple{Float64, Float64}" href="#BoltzmannCollisionIntegral.sigma_ElePhoElePho-Tuple{Float64, Float64}"><code>BoltzmannCollisionIntegral.sigma_ElePhoElePho</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sigma_ElePhoElePho(sSmol,sBig)</code></pre><p>returns the total cross section for electron-photon (Compton) scattering. Berestetskii 1982 (86.16). Masses and momenta are normalised by the rest mass of the electron <span>$m_{\text{Ele}}$</span> and the cross section is normalised by <span>$σ_T$</span>.</p><p class="math-container">\[\sigma_{e\gamma\rightarrow e\gamma}(s)=\frac{3}{4(s-1)}\left[(1-\frac{4}{\left(s-1\right)}-\frac{8m_e^4}{\left(s-1\right)^2})\log\left(s\right)+\frac{1}{2}+\frac{8}{s-1}-\frac{1}{2s^2}\right]\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : <span>$s - sBig$</span></li><li><code>sBig::Float64</code> : <span>$(m_1+m_2)^2 = 1 ∴ s = sSmol + 1$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/DifferentialCrossSectionFunctions.jl#L211-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.sigma_ElePosPhoPho-Tuple{Float64, Float64}" href="#BoltzmannCollisionIntegral.sigma_ElePosPhoPho-Tuple{Float64, Float64}"><code>BoltzmannCollisionIntegral.sigma_ElePosPhoPho</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sigma_ElePosPhoPho(sSmol,sBig)</code></pre><p>returns the total cross section for electron positron annihilation to two photons. Berestetskii 1982 (88.6). Masses and momenta are normalised by the rest mass of the electron <span>$m_{\text{Ele}}$</span> and the cross section is normalised by <span>$σ_T$</span>.</p><p class="math-container">\[σ_{e^+e^-\rightarrow\gamma\gamma} = \frac{3}{4s^2(s-4)}\left((s^2+4s-8)\log\left(\frac{\sqrt{s}+\sqrt{s-4}}{\sqrt{s}-\sqrt{s-4}}\right)-(s+4)\sqrt{s(s-4)}\right)\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : <span>$s - sBig$</span></li><li><code>sBig::Float64</code> : <span>$(m_1+m_2)^2 = 4 ∴ s = sSmol + 4$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/DifferentialCrossSectionFunctions.jl#L89-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.sigma_PhoPhoElePos-Tuple{Float64, Float64}" href="#BoltzmannCollisionIntegral.sigma_PhoPhoElePos-Tuple{Float64, Float64}"><code>BoltzmannCollisionIntegral.sigma_PhoPhoElePos</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sigma_PhoPhoElePos(sSmol,sBig)</code></pre><p>returns the total cross section for photon-photon annihilation to electron-positron pair. Masses and momenta are normalised by the rest mass of the electron <span>$m_{\text{Ele}}$</span> and the cross section is normalised by <span>$σ_T$</span>.</p><p class="math-container">\[σ_{\gamma\gamma\rightarrow e^+e^-} = \frac{3}{2s^3}\left((s^2+4s-8)\log\left(\frac{\sqrt(s)+\sqrt(s-4)}{\sqrt(s)-\sqrt(s-4)}\right)-(s+4)\sqrt{s(s-4)}\right)\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : <span>$s - sBig$</span></li><li><code>sBig::Float64</code> : <span>$(m_1+m_2)^2 = 0 ∴ s = sSmol$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/DifferentialCrossSectionFunctions.jl#L144-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.sigma_SphSphSphSph-Tuple{Float64, Float64}" href="#BoltzmannCollisionIntegral.sigma_SphSphSphSph-Tuple{Float64, Float64}"><code>BoltzmannCollisionIntegral.sigma_SphSphSphSph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sigma_SphSphSphSph(sSmol,sBig)</code></pre><p>returns the total cross section for the binary interaction of hard spheres with normalised masses (wrt electron mass) <span>$m_1,m_2,m_3,m_4=m_\text{Sph}$</span>. Normalised by <span>$πR_{Sph}^2$</span>.</p><p class="math-container">\[σ = \frac{1}{2}\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : s - sBig</li><li><code>sBig::Float64</code> : (m1+m2)^2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Binary/Common/DifferentialCrossSectionFunctions.jl#L37-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.vectorLocation-Tuple{Float64, Float64, Int64, Int64, Vector{Float64}}" href="#BoltzmannCollisionIntegral.vectorLocation-Tuple{Float64, Float64, Int64, Int64, Vector{Float64}}"><code>BoltzmannCollisionIntegral.vectorLocation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vectorLocation(pu,pl,nump,numt,vector)</code></pre><p>Returns a tuple of bin location for (log10momentum,cos(theta)) based on an input &#39;vector&#39; and bounds &#39;u,l&#39; of their domains and the &#39;num&#39; of uniformly spaced bins. costheta bounds [tl tu] are defined as CONST in Init.jl</p><p><strong>Examples</strong></p><p>```julia-repl julia&gt; vectorLocation(4e0,-5e0,9,8,[1e0,0.5e0,1.5e0]) (5,6)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/238daec850f9b988892d4021d837df8175dfab2b/src/Common/Location.jl#L107-L117">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../synchrotron/">« Synchrotron Emissions</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.0 on <span class="colophon-date" title="Friday 9 May 2025 11:21">Friday 9 May 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
