<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internal Functions · BoltzmannCollisionIntegral.jl</title><meta name="title" content="Internal Functions · BoltzmannCollisionIntegral.jl"/><meta property="og:title" content="Internal Functions · BoltzmannCollisionIntegral.jl"/><meta property="twitter:title" content="Internal Functions · BoltzmannCollisionIntegral.jl"/><meta name="description" content="Documentation for BoltzmannCollisionIntegral.jl."/><meta property="og:description" content="Documentation for BoltzmannCollisionIntegral.jl."/><meta property="twitter:description" content="Documentation for BoltzmannCollisionIntegral.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="BoltzmannCollisionIntegral.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="BoltzmannCollisionIntegral.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">BoltzmannCollisionIntegral.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../quickstart/">Getting Started</a></li><li><a class="tocitem" href="../crosssections/">Grids, Particles and Cross Sections</a></li><li><a class="tocitem" href="../synchrotron/">Synchrotron Emissions</a></li><li class="is-active"><a class="tocitem" href>Internal Functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Internal Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internal Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/main/docs/src/internalfunctions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal-Functions"><a class="docs-heading-anchor" href="#Internal-Functions">Internal Functions</a><a id="Internal-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.DoesConserve-NTuple{5, Any}" href="#BoltzmannCollisionIntegral.DoesConserve-NTuple{5, Any}"><code>BoltzmannCollisionIntegral.DoesConserve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DoesConserve(SMatrix3,SMatrix4,TMatrix1,TMatrix2,Parameters)</code></pre><p>Function prints the ratio of the sum of the S and T matrices and their differences, for all interaction paths, as to check number and energy conservation for a particular interaction. Arguments are as outputted by the <code>fload_All</code> function. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/DataReading.jl#L193-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.InvarientFlux-Tuple{Float64, Float64, Float64}" href="#BoltzmannCollisionIntegral.InvarientFlux-Tuple{Float64, Float64, Float64}"><code>BoltzmannCollisionIntegral.InvarientFlux</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InvarientFlux(s,mu12,mu22)</code></pre><p>returns the value of the invarient flux with &#39;s&#39; mandelstram variable and masses &#39;mass1&#39; and &#39;mass2&#39;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/STValue.jl#L246-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.InvarientFlux2-Tuple{Float64, Float64, Float64}" href="#BoltzmannCollisionIntegral.InvarientFlux2-Tuple{Float64, Float64, Float64}"><code>BoltzmannCollisionIntegral.InvarientFlux2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InvarientFlux2(s,mass12,mass22)</code></pre><p>returns the value of the squared invarient flux with &#39;s&#39; mandelstram variable and masses &#39;mass1&#39; and &#39;mass2&#39;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/STValue.jl#L271-L275">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.InvarientFlux2Small-Tuple{Float64, Float64, Float64}" href="#BoltzmannCollisionIntegral.InvarientFlux2Small-Tuple{Float64, Float64, Float64}"><code>BoltzmannCollisionIntegral.InvarientFlux2Small</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InvarientFluxSmall(sSmol,mass12,mass22)</code></pre><p>returns the value of the squared invarient flux with smalled &#39;s&#39; mandelstram variable (sSmol = s - (m1+m2)^2)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/STValue.jl#L283-L287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.InvarientFluxSmall-Tuple{Float64, Float64, Float64}" href="#BoltzmannCollisionIntegral.InvarientFluxSmall-Tuple{Float64, Float64, Float64}"><code>BoltzmannCollisionIntegral.InvarientFluxSmall</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InvarientFluxSmall(sSmol,mu12,mu22)</code></pre><p>returns the value of the invarient flux with smalled &#39;s&#39; mandelstram variable (sSmol = s - (m1+m2)^2)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/STValue.jl#L258-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.Momentum3Value!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vararg{Float64, 4}}" href="#BoltzmannCollisionIntegral.Momentum3Value!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vararg{Float64, 4}}"><code>BoltzmannCollisionIntegral.Momentum3Value!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Momentum3Value!(p3v,p3pv,p1v,p2v)</code></pre><p>Takes set of random initial particle states &#39;p1v&#39; and &#39;p2v&#39; and random output states angles &#39;p3v[2:3]&#39; and modifies outputs &#39;p3v&#39; and &#39;p3pv&#39; values with calculated output momentum and corrects angles if momentum is negative. Function also returns a two bools &#39;p3<em>physical&#39; and &#39;p3p</em>physical&#39; indicating if p3 and p3p are physical momentum states given the inputs.  Function also returns a Int &#39;NumStates&#39; indicating the number of valid output states found.</p><p>Requrires normalised masses (mu1,mu2,mu3,mu4) to be defined in advance in Init.jl as const.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mu1 = 1836.1528e0
julia&gt; mu2 = 1836.1528e0
julia&gt; mu3 = 1836.1528e0
julia&gt; mu4 = 1836.1528e0
julia&gt; p1v = [1e0, 0.5e0, 1.8e0]
julia&gt; p2v = [2e0, 0.2e0, 0.7e0]
julia&gt; p3v = [0e0, 0.3e0, 0.7e0]
julia&gt; p3pv = zeros(Float64,3)
julia&gt; p3pv .= p3v
julia&gt; Momentum3Value!(p3v,p3pv,p1v,p2v,mu1,mu2,mu3,mu4)
(true,true,2)
julia&gt; p3v
 3-element Vector{Float64}:
 2.04505
 0.3
 0.7
julia&gt; p3pv
 3-element Vector{Float64}
 0.691423
 -0.3
 1.7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/Momentum3Values.jl#L2-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.PhaseSpaceFactors1!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Bool}" href="#BoltzmannCollisionIntegral.PhaseSpaceFactors1!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Bool}"><code>BoltzmannCollisionIntegral.PhaseSpaceFactors1!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PhaseSpaceFactors1!(SMatrix3,SMatrix4,TMatrix,u3_bounds,u4_bounds,p1_bounds,u1_bounds,p2_bounds,u2_bounds,Indistinguishable_12)</code></pre><p>Applies phase space volume element factors for &#39;SMatrix&#39; and &#39;TMatrix&#39; terms in order to correctly apply &#39;STSymmetry&#39; corrections. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/PhaseSpaceFactors.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.PhaseSpaceFactors2!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Array{Float64, 4}, Vararg{Vector{Float64}, 8}}" href="#BoltzmannCollisionIntegral.PhaseSpaceFactors2!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Array{Float64, 4}, Vararg{Vector{Float64}, 8}}"><code>BoltzmannCollisionIntegral.PhaseSpaceFactors2!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PhaseSpaceFactors2!(SMatrix3,SMatrix4,TMatrix,p3_bounds,u3_bounds,p4_bounds,u4_bounds,p1_bounds,u1_bounds,p2_bounds,u2_bounds)</code></pre><p>To follow &#39;PhaseSpaceFactors1&#39; and &#39;STSymmetry&#39;. Corrects phase space factors on &#39;SMatrix&#39; and &#39;TMatrix&#39; for use in kinetic codes. Assumes f(x,p,μ)= constant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/PhaseSpaceFactors.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.PhaseSpaceFactorsSync1!-Tuple{Array{Float64, 4}, Vararg{Vector{Float64}, 4}}" href="#BoltzmannCollisionIntegral.PhaseSpaceFactorsSync1!-Tuple{Array{Float64, 4}, Vararg{Vector{Float64}, 4}}"><code>BoltzmannCollisionIntegral.PhaseSpaceFactorsSync1!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PhaseSpaceFactorsSync1!(SMatrix,p1val,t1val,p2val,t2val)</code></pre><p>Applies phase space volume element factors for &#39;SMatrix&#39; terms in order to correctly apply &#39;SyncSymmetry&#39; corrections. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Synchrotron/Common/SyncPhaseSpaceFactors.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.PhaseSpaceFactorsSync2!-Tuple{Array{Float64, 4}, Vector{Float64}, Vector{Float64}}" href="#BoltzmannCollisionIntegral.PhaseSpaceFactorsSync2!-Tuple{Array{Float64, 4}, Vector{Float64}, Vector{Float64}}"><code>BoltzmannCollisionIntegral.PhaseSpaceFactorsSync2!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PhaseSpaceFactorsSync2!(SMatrix,p1val,t1val)</code></pre><p>To follow &#39;PhaseSpaceFactorsSync1&#39; and &#39;SyncSymmetry&#39;. Correct phase spcae factors on &#39;SMatrix&#39; for use in kinetic codes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Synchrotron/Common/SyncPhaseSpaceFactors.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.RPointLogMomentum!-Tuple{Vector{Float64}, Float64, Float64, Int64}" href="#BoltzmannCollisionIntegral.RPointLogMomentum!-Tuple{Vector{Float64}, Float64, Float64, Int64}"><code>BoltzmannCollisionIntegral.RPointLogMomentum!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RPointLogMomentum!(pu,pl,pv,num)</code></pre><p>Edits the first element of <code>pv</code> with a random real-space momentum value between <span>$10^{pl}$</span> and <span>$10^{pu}$</span>. This sample is chosen by first randomly picking a momentum bin in the range <code>1:num</code> and then uniformly sampling a momentum point in real-space (rather than log10 space) between pl and pu which are the momentum values at start and end of that bin. Sampling is done such there will be a constant number of points per momentum-space volume. As the momentum space between <span>$10^{pl}$</span> and <span>$10^{pu}$</span> it is a spherical shell hence the correct sampling is <span>$p = (U*(10^{pu})^3+(1-U)*(10^{pl})^3)^{1/3}$</span> with uniform <span>$U ∈ [0~~1]$</span>.</p><p>Assumes <span>$f(x,p,μ)=f(x,\vec{p})*(2πp^2)=const$</span> in bin, therefore momentum space volume element is <span>$\mathrm{d}p$</span> and as such uniform sampling corresponds to <span>$U*10^{u}+(1-U)*10^{l}$</span> where <span>$U$</span> is a uniform random number between 0 and 1.</p><p>If instead <span>$f(x,\vec{p})=const$</span> in bin, momentum space volume element is <span>$p^2 \mathrm{d}p$</span> and uniform sampling corresponds to <span>$(10^pu)*\sqrt[3]{U+(1-U)*10^{3pl-3pu}}$</span> where <span>$U$</span> is a uniform random number between 0 and 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/RandomPoints.jl#L5-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.RPointSphereCosTheta!-Tuple{Vector{Float64}}" href="#BoltzmannCollisionIntegral.RPointSphereCosTheta!-Tuple{Vector{Float64}}"><code>BoltzmannCollisionIntegral.RPointSphereCosTheta!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RPointSphereTheta!()</code></pre><p>Assigns the second (cos(theta)) element of &#39;a&#39; with a randomly, uniformly sampled values of spherical angles cos(theta). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/RandomPoints.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.RPointSphereCosThetaPhi!-Tuple{Vector{Float64}}" href="#BoltzmannCollisionIntegral.RPointSphereCosThetaPhi!-Tuple{Vector{Float64}}"><code>BoltzmannCollisionIntegral.RPointSphereCosThetaPhi!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RPointSphereThetaPhi!()</code></pre><p>Assigns the second (cos(theta)) and third (phi) elements of &#39;a&#39; with a randomly, uniformly sampled values of spherical angles cos(theta) and phi (phi normalised by pi). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/RandomPoints.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.STMonteCarloAxi_MultiThread!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Array{UInt32, 5}, Array{UInt32, 5}, Array{UInt32, 4}, Any, Array{Float64, 5}, Array{Float64, 5}, Array{Float64, 6}, Array{Float64, 6}, Function, Function, Tuple{String, String, String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64}, Int64, Int64}" href="#BoltzmannCollisionIntegral.STMonteCarloAxi_MultiThread!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Array{UInt32, 5}, Array{UInt32, 5}, Array{UInt32, 4}, Any, Array{Float64, 5}, Array{Float64, 5}, Array{Float64, 6}, Array{Float64, 6}, Function, Function, Tuple{String, String, String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64}, Int64, Int64}"><code>BoltzmannCollisionIntegral.STMonteCarloAxi_MultiThread!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">STMonteCarloAxi_MultiThread!(SAtotal3,SAtotal4,TAtotal,SAtally3,SAtally4,TAtally,p3Max,u3MinMax,p4Max,u4MinMax,sigma,dsigmadt,Parameters,numTiterPerThread,numSiterPerThread)</code></pre><p><strong>Arguments</strong></p><ul><li><code>SAtotal3::Array{Float64,6}</code> : Array of stored integration totals for S matrix for 12-&gt;34 interaction</li><li><code>SAtotal4::Array{Float64,6}</code> : Array of stored integration totals for S matrix for 12-&gt;43 interaction</li><li><code>TAtotal::Array{Float64,4}</code> : Array of stored integration totals for T matrix</li><li><code>SAtally3::Array{UInt32,5}</code> : Array of stored integration tallies for S matrix for 12-&gt;34 interaction</li><li><code>SAtally4::Array{UInt32,5}</code> : Array of stored integration tallies for S matrix for 12-&gt;43 interaction</li><li><code>TAtally::Array{UInt32,4}</code> : Array of stored integration tallies for T matrix</li><li><code>p3Max::Array{Float64,5}</code> : Array of maximum momentum values for species 3</li><li><code>u3MinMax::Array{Float64,6}</code> : Array of minimum and maximum theta values for species 3</li><li><code>p4Max::Array{Float64,5}</code> : Array of maximum momentum values for species 4</li><li><code>u4MinMax::Array{Float64,6}</code> : Array of minimum and maximum theta values for species 4</li><li><code>sigma::Function</code> : Cross section function for the interaction</li><li><code>dsigmadt::Function</code> : Differential cross section function for the interaction</li><li><code>Parameters::Tuple{Float64,Float64,Float64,Float64,Float64,Float64,Int64,Float64,Float64,Int64,Float64,Float64,Int64,Float64,Float64,Int64,Int64,Int64,Int64,Int64}</code> : Tuple of parameters for the interaction</li><li><code>numTiterPerThread::Int64</code> : Number of T iterations per thread</li><li><code>numSiterPerThread::Int64</code> : Number of S iterations per thread</li></ul><p><strong>Output:</strong></p><ul><li>Argument arrays SAtotal,TAtotal,SAtally,TAtally are mutated to include the results of the Monte Carlo Integration.</li></ul><p><strong>Calculation In Brief</strong></p><ul><li>Set up worker threads</li><li>Random Sample points in each of these domains<ul><li>RandomPointSphere for theta and phi (for species 1,2,3,4)</li><li>RandomPointMomentum for p ( species 1,2 only)</li></ul></li><li>Take random points (u3,h3,p1,p2,u1,u2,h1,h2) and calculate valid p3 point/points </li><li>Find position in local S and T arrays and allocated tallies and totals accordingly.</li><li>Take random points (u4,h3,p1,p2,u1,u2,h1,h2) and calculate valid p4 point/points </li><li>Find position in local S and T arrays and allocated tallies and totals accordingly.</li><li>Update global S and T arrays with locks to prevent data races</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/MultiThread/STMonteCarlo_MultiThread.jl#L6-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.STMonteCarloAxi_Serial!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Array{UInt32, 5}, Array{UInt32, 5}, Array{UInt32, 4}, Array{Float64, 5}, Array{Float64, 5}, Array{Float64, 6}, Array{Float64, 6}, Function, Function, Tuple{String, String, String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64}, Int64, Int64}" href="#BoltzmannCollisionIntegral.STMonteCarloAxi_Serial!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Array{UInt32, 5}, Array{UInt32, 5}, Array{UInt32, 4}, Array{Float64, 5}, Array{Float64, 5}, Array{Float64, 6}, Array{Float64, 6}, Function, Function, Tuple{String, String, String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64}, Int64, Int64}"><code>BoltzmannCollisionIntegral.STMonteCarloAxi_Serial!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">STMonteCarloAxi_Serial!(SAtotal3,SAtotal4,TAtotal,SAtally3,SAtally4,TAtally,p3Max,p4Max,t3MinMax,t4MinMax,sigma,dsigmadt,Parameters,numTiter,numSiter)</code></pre><p><strong>Arguments</strong></p><ul><li><code>SAtotal3::Array{Float64,6}</code> : Array of stored integration totals for S matrix for 12-&gt;34 interaction</li><li><code>SAtotal4::Array{Float64,6}</code> : Array of stored integration totals for S matrix for 12-&gt;43 interaction</li><li><code>TAtotal::Array{Float64,4}</code> : Array of stored integration totals for T matrix</li><li><code>SAtally3::Array{UInt32,5}</code> : Array of stored integration tallies for S matrix for 12-&gt;34 interaction</li><li><code>SAtally4::Array{UInt32,5}</code> : Array of stored integration tallies for S matrix for 12-&gt;43 interaction</li><li><code>TAtally::Array{UInt32,4}</code> : Array of stored integration tallies for T matrix</li><li><code>p3Max::Array{Float64,5}</code> : Array of maximum momentum values for species 3</li><li><code>t3MinMax::Array{Float64,6}</code> : Array of minimum and maximum theta values for species 3</li><li><code>p4Max::Array{Float64,5}</code> : Array of maximum momentum values for species 4</li><li><code>t4MinMax::Array{Float64,6}</code> : Array of minimum and maximum theta values for species 4</li><li><code>sigma::Function</code> : Cross section function for the interaction</li><li><code>dsigmadt::Function</code> : Differential cross section function for the interaction</li><li><code>Parameters::Tuple{Float64,Float64,Float64,Float64,Float64,Float64,Int64,Float64,Float64,Int64,Float64,Float64,Int64,Float64,Float64,Int64,Int64,Int64,Int64,Int64}</code> : Tuple of parameters for the interaction</li><li><code>numTiter::Int64</code> : Number of T iterations</li><li><code>numSiter::Int64</code> : Number of S iterations</li></ul><p><strong>Output:</strong></p><ul><li>Argument arrays SAtotal,TAtotal,SAtally,TAtally are mutated to include the results of the Monte Carlo Integration.</li></ul><p><strong>Calculation In Breif</strong></p><ul><li>Random Sample points in each of these domains<ul><li>RandomPointSphere for theta and phi (for species 1,2,3,4)</li><li>RandomPointMomentum for p ( species 1,2 only)</li></ul></li><li>Take random points (u3,h3,p1,pu2_grid2,u1,u2,h1,h2) and calculate valid p3 point/points </li><li>Find position in local S and T arrays and allocated tallies and totals accordingly.</li><li>Take random points (u4,h3,p1,p2,u1,u2,h1,h2) and calculate valid p4 point/points </li><li>Find position in local S and T arrays and allocated tallies and totals accordingly.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Serial/STMonteCarlo_Serial.jl#L6-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.STSymmetry!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Float64, Float64}" href="#BoltzmannCollisionIntegral.STSymmetry!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Float64, Float64}"><code>BoltzmannCollisionIntegral.STSymmetry!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">STSymmetry!(SMatrix3,SMatrix4,TMatrix,u3_bounds,mu1,mu2)</code></pre><p>To follow &#39;PhaseSpaceFactors1&#39;. Physical nature of binary interaction has certain symmetries. &#39;STSymmetry&#39; uses these symmetries to improve MC sampling of &#39;SMatrix&#39; and &#39;TMatrix&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/PhaseSpaceFactors.jl#L84-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.SValue3-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Function, Vararg{Float64, 4}}" href="#BoltzmannCollisionIntegral.SValue3-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Function, Vararg{Float64, 4}}"><code>BoltzmannCollisionIntegral.SValue3</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SValue3(p3v,p1v,p2v,dsigmadt,mu1,mu2,mu3)</code></pre><p>Returns <code>Sval</code> from MC integration based on initial momentum states <code>p1v</code> and <code>p2v</code> and final state <code>p3v</code> and differential cross section <code>dsigmadt</code> based on particle selection 12-&gt;34.   Assumes f(x,p,μ)=constant over bin</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/STValue.jl#L66-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.SValue4-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Function, Vararg{Float64, 4}}" href="#BoltzmannCollisionIntegral.SValue4-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Function, Vararg{Float64, 4}}"><code>BoltzmannCollisionIntegral.SValue4</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SValue4(p3v,p1v,p2v,dsigmadt,mu1,mu2,mu3,mu4)</code></pre><p>Returns <code>Sval</code> from MC integration based on initial momentum states <code>p1v</code> and <code>p2v</code> and final state <code>p4v</code> and differential cross section <code>dsigmadt</code> based on particle selection 12-&gt;34.   Assumes f(x,p,μ)=constant over bin</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/STValue.jl#L156-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.SpectraEvaluateMultiThread-Tuple{Tuple{Tuple{String, String, String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64}, Int64, Int64, Int64, String, String}}" href="#BoltzmannCollisionIntegral.SpectraEvaluateMultiThread-Tuple{Tuple{Tuple{String, String, String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64}, Int64, Int64, Int64, String, String}}"><code>BoltzmannCollisionIntegral.SpectraEvaluateMultiThread</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpectraEvaluateMultiThread(userInputMultiThread)</code></pre><p>Function to run the Monte Carlo integration of the S and T arrays in a multi-threaded environment. The function will run the Monte Carlo integration in parallel across the number of threads specified in the global variable nThreads. The function will then calculate the S and T matrices and save the results to a file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/MultiThread/STIntegration_MultiThread.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.SpectraEvaluateSerial-Tuple{Tuple{Tuple{String, String, String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64}, Int64, Int64, String, String}}" href="#BoltzmannCollisionIntegral.SpectraEvaluateSerial-Tuple{Tuple{Tuple{String, String, String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64}, Int64, Int64, String, String}}"><code>BoltzmannCollisionIntegral.SpectraEvaluateSerial</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpectraEvaluateSerial(userInputSerial)</code></pre><p>Function to run the Monte Carlo integration of the S and T arrays in a serial environment. The function will run the Monte Carlo integration in serial and then calculate the S and T matrices and save the results to a file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Serial/STIntegration_Serial.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.SyncEvaluateMultiThread-Tuple{Tuple{Tuple{String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64}, Int64, Int64, Int64, String, String}}" href="#BoltzmannCollisionIntegral.SyncEvaluateMultiThread-Tuple{Tuple{Tuple{String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64}, Int64, Int64, Int64, String, String}}"><code>BoltzmannCollisionIntegral.SyncEvaluateMultiThread</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SyncEvaluateMultiThread!(userSyncInputMultiThread)</code></pre><p>Function to run the Monte Carlo integration of the S array in a serial enviroment. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Synchrotron/MultiThread/SyncIntegration_MultiThread.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.SyncEvaluateSerial-Tuple{Tuple{Tuple{String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64}, Int64, Int64, String, String}}" href="#BoltzmannCollisionIntegral.SyncEvaluateSerial-Tuple{Tuple{Tuple{String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64}, Int64, Int64, String, String}}"><code>BoltzmannCollisionIntegral.SyncEvaluateSerial</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SyncEvaluateSerial!(userSyncInputSerial)</code></pre><p>Function to run the Monte Carlo integration of the S array in a serial environment. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Synchrotron/Serial/SyncIntegration_Serial.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.SyncKernel-NTuple{5, Any}" href="#BoltzmannCollisionIntegral.SyncKernel-NTuple{5, Any}"><code>BoltzmannCollisionIntegral.SyncKernel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SyncKernel(p1v,p2v,m2,z2,B)</code></pre><p>Returns the emission rate for a single photon <span>$p1v$</span> state emitted by a charged particle in state <span>$p2v$</span> with charge <span>$z2$</span> relative to the fundamental charge and mass <span>$m2$</span> relative to the mass of the electron, in a unifrom magnetic field <span>$B$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Synchrotron/Common/SynchrotronKernel.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.SyncMonteCarloAxi_MultiThread!-Tuple{Array{Float64, 4}, Array{UInt32, 4}, Any, Tuple{String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64}, Int64, Int64, Int64}" href="#BoltzmannCollisionIntegral.SyncMonteCarloAxi_MultiThread!-Tuple{Array{Float64, 4}, Array{UInt32, 4}, Any, Tuple{String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64}, Int64, Int64, Int64}"><code>BoltzmannCollisionIntegral.SyncMonteCarloAxi_MultiThread!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SyncMonteCarloAxi_MultiThread!(SAtotal,SAtally,pMax,tMinMax,Parameters,numSiter)</code></pre><p><strong>Arguments</strong></p><ul><li><code>SAtotal::Array{Float64,4}</code> : Array of stored integration totals for S matrix for 2+B-&gt;2+B+1 interaction</li><li><code>SAtally::Array{UInt32,4}</code> : Array of stored integration tallies for S matrix for 2+B-&gt;2+B+1 interaction</li><li><code>pMax::Array{Float64,3}</code> : Array of maximum momentum values for species 2</li><li><code>tMinMax::Array{Float64,3}</code> : Array of minimum and maximum theta values for species 2</li><li><code>Parameters::Tuple{Float64,Float64,Float64,Int64,Float64,Float64,Int64,Int64,Int64}</code> : Tuple of parameters for the interaction</li><li><code>numSiter::Int64</code> : Number of S iterations</li></ul><p><strong>Output:</strong></p><ul><li>Argument arrays SAtotal,SAtally are mutated to include the results of the Monte Carlo Integration.</li></ul><p><strong>Calculation In Brief</strong></p><ul><li>Random Sample points in each of these domains<ul><li>RandomPointSphere for theta (for species 1,2)</li><li>RandomPointMomentum for p ( species 1,2)</li></ul></li><li>Take random points (p1,p2,t1,t2) and calculate Synchrotron emissivity</li><li>Find position in S arrays and allocated tallies and totals accordingly.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Synchrotron/MultiThread/SyncMonteCarlo_MultiThread.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.SyncMonteCarloAxi_Serial!-Tuple{Array{Float64, 4}, Array{UInt32, 4}, Tuple{String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64}, Int64, Int64}" href="#BoltzmannCollisionIntegral.SyncMonteCarloAxi_Serial!-Tuple{Array{Float64, 4}, Array{UInt32, 4}, Tuple{String, String, Float64, Float64, Float64, Float64, Float64, Float64, String, Int64, String, Int64, Float64, Float64, String, Int64, String, Int64, Float64}, Int64, Int64}"><code>BoltzmannCollisionIntegral.SyncMonteCarloAxi_Serial!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SyncMonteCarloAxi_Serial!(SAtotal,SAtally,pMax,tMinMax,Parameters,numSiter)</code></pre><p><strong>Arguments</strong></p><ul><li><code>SAtotal::Array{Float64,4}</code> : Array of stored integration totals for S matrix for 2+B-&gt;2+B+1 interaction</li><li><code>SAtally::Array{UInt32,4}</code> : Array of stored integration tallies for S matrix for 2+B-&gt;2+B+1 interaction</li><li><code>pMax::Array{Float64,3}</code> : Array of maximum momentum values for species 2</li><li><code>tMinMax::Array{Float64,3}</code> : Array of minimum and maximum theta values for species 2</li><li><code>Parameters::Tuple{Float64,Float64,Float64,Int64,Float64,Float64,Int64,Int64,Int64}</code> : Tuple of parameters for the interaction</li><li><code>numSiter::Int64</code> : Number of S iterations</li></ul><p><strong>Output:</strong></p><ul><li>Argument arrays SAtotal,SAtally are mutated to include the results of the Monte Carlo Integration.</li></ul><p><strong>Calculation In Brief</strong></p><ul><li>Random Sample points in each of these domains<ul><li>RandomPointSphere for theta (for species 1,2)</li><li>RandomPointMomentum for p ( species 1,2)</li></ul></li><li>Take random points (p1,p2,t1,t2) and calculate Synchrotron emissivity</li><li>Find position in S arrays and allocated tallies and totals accordingly.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Synchrotron/Serial/SyncMonteCarlo_Serial.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.SyncSymmetry!-Tuple{Array{Float64, 4}}" href="#BoltzmannCollisionIntegral.SyncSymmetry!-Tuple{Array{Float64, 4}}"><code>BoltzmannCollisionIntegral.SyncSymmetry!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SyncSymmetry!(SMatrix)</code></pre><p>To follow &#39;PhaseSpaceFactorsSync1&#39;. Synchrotron emission has a symmetry with respect to cos(theta) -&gt; -cos(theta) for both initial particle and photon momenta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Synchrotron/Common/SyncPhaseSpaceFactors.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.TValue-Tuple{Vector{Float64}, Vector{Float64}, Function, Vararg{Float64, 4}}" href="#BoltzmannCollisionIntegral.TValue-Tuple{Vector{Float64}, Vector{Float64}, Function, Vararg{Float64, 4}}"><code>BoltzmannCollisionIntegral.TValue</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TValue(p1v,p2v,sigma,mu1,mu2)</code></pre><p>returns <code>Tval</code> with its Tval from MC integration based on initial momentum states <code>p1v</code> and <code>p2v</code> and cross section <code>sigma</code> based on particle selection. If initial state fails <code>sCheck</code>, i.e. cannot generate a physical output state, Tval is set to 0e0.  Assumes f(x,p,μ)=constant over bin</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/STValue.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.bounds-Union{Tuple{T}, Tuple{T, T, Int64, String}} where T&lt;:Union{Float32, Float64}" href="#BoltzmannCollisionIntegral.bounds-Union{Tuple{T}, Tuple{T, T, Int64, String}} where T&lt;:Union{Float32, Float64}"><code>BoltzmannCollisionIntegral.bounds</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bounds(up_bound,low_bound,num,spacing)</code></pre><p>Returns a <code>num+1</code> long <code>Vector{Float}</code> of grid bounds. These grid bounds can spaced either by      - linear spacing: <code>spacing = &quot;u&quot;</code>     - log10 spacing: <code>spacing = &quot;l&quot;</code>     - binary (1/2^n) spacing: <code>spacing = &quot;b&quot;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/UsefulGridValueFunctions.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.bounds_p-Union{Tuple{T}, Tuple{T, T, Int64}} where T&lt;:Union{Float32, Float64}" href="#BoltzmannCollisionIntegral.bounds_p-Union{Tuple{T}, Tuple{T, T, Int64}} where T&lt;:Union{Float32, Float64}"><code>BoltzmannCollisionIntegral.bounds_p</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bounds_p(pl,pu,nump)</code></pre><p>Returns a <code>nump+1</code> long <code>Vector{Float}</code> of p-space grid bounds NOT in Log10 space.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bounds_p(-5e0,4e0,9)
10-element Vector{Float64}:
 1.0e-5
 1.0e-4
 1.0e-3
 0.01
 0.1
 1.0
 10.0
 100.0
 1000.0
 10000.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/UsefulGridValueFunctions.jl#L27-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.bounds_t-Tuple{Int64}" href="#BoltzmannCollisionIntegral.bounds_t-Tuple{Int64}"><code>BoltzmannCollisionIntegral.bounds_t</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bounds_t(numt)</code></pre><p>Returns a <code>numt+1</code> long <code>Vector{Float}</code> of theta-space grid bounds in terms of cos(theta). Upper and lower bounds [tl tu] are defined as CONST in Init.jl as [-1 1], type returned is that of tl, tu.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bounds_t(8)
9-element Vector{Float64}:
 -1.0
 -0.75
 -0.5
 -0.25
  0.0
  0.25
  0.5
  0.75
  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/UsefulGridValueFunctions.jl#L53-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.deltaEVector-Union{Tuple{T}, Tuple{Vector{T}, T}} where T&lt;:Union{Float32, Float64}" href="#BoltzmannCollisionIntegral.deltaEVector-Union{Tuple{T}, Tuple{Vector{T}, T}} where T&lt;:Union{Float32, Float64}"><code>BoltzmannCollisionIntegral.deltaEVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deltaEVector(pr,mu)</code></pre><p>Inputs a <code>num+1</code> long <code>Vector{Float}</code> of p grid boundaries and the particle <code>mu</code> value (normalised mass) and returns a <code>num</code> long <code>Vector{Float}</code> of average energy values per grid cell.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; deltaEVector([1.0e0, 10.0e0, 100.0e0, 1000.0e0], 1.0e0)
3-element Vector{Float64}:
 50.600693
 4951.15
 495001.16</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/UsefulGridValueFunctions.jl#L137-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.deltaEkinVector-Union{Tuple{T}, Tuple{Vector{T}, T}} where T&lt;:Union{Float32, Float64}" href="#BoltzmannCollisionIntegral.deltaEkinVector-Union{Tuple{T}, Tuple{Vector{T}, T}} where T&lt;:Union{Float32, Float64}"><code>BoltzmannCollisionIntegral.deltaEkinVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deltaEkinVector(pr,mu)</code></pre><p>Inputs a <code>num+1</code> long <code>Vector{Float}</code> of p grid boundaries and the particle <code>mu</code> value (normalised mass) and returns a <code>num</code> long <code>Vector{Float}</code> of average kinetic energy values per grid cell.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; deltaEkinVector([1.0e0, 10.0e0, 100.0e0, 1000.0e0], 1.0e0)
3-element Vector{Float64}:
     46.10069600605712
   4906.1506753523645
 494551.15128635924</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/UsefulGridValueFunctions.jl#L180-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.deltaVector-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64}" href="#BoltzmannCollisionIntegral.deltaVector-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64}"><code>BoltzmannCollisionIntegral.deltaVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deltaVector(valr)</code></pre><p>Inputs a <code>num+1</code> long <code>Vector{Float}</code> quantity values (domain bounds) and returns a <code>num</code> long <code>Vector{Float}</code> of differences (domain widths).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; deltaVector([1.0e0, 10.0e0, 100.0e0, 1000.0e0])
3-element Vector{Float64}:
 9.0
 90.0
 900.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/UsefulGridValueFunctions.jl#L81-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.dsigmadt_ElePhoElePho-NTuple{6, Float64}" href="#BoltzmannCollisionIntegral.dsigmadt_ElePhoElePho-NTuple{6, Float64}"><code>BoltzmannCollisionIntegral.dsigmadt_ElePhoElePho</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dsigmadt_ElePhoElePho(sSmol,sBig,tSmol,tBig,uSmol,uBig)</code></pre><p>returns the differential cross section for electron-photon scattering (Compton) scattering. Berestetskii 1982 (86.6). Masses and momenta are normalised by the rest mass of the electron <span>$m_{\text{Ele}}$</span> and the cross section is normalised by <span>$σ_T$</span>.</p><p class="math-container">\[\frac{d\sigma_{e\gamma\rightarrow e\gamma}}{dt}(s,t)=\frac{3}{(s-1)^2}\left[\left(\frac{1}{s-1}+\frac{1}{u-1}\right)^2+\left(\frac{1}{s-1}+\frac{1}{u-1}\right)-\frac{1}{4}\left(\frac{s-1}{u-1}+\frac{u-1}{s-1}\right)\right]\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : <span>$s - sBig$</span></li><li><code>sBig::Float64</code> : <span>$(m_1+m_2)^2 = 1 ∴ s = sSmol + 1$</span></li><li><code>tSmol::Float64</code> : <span>$t - tBig$</span></li><li><code>tBig::Float64</code> : <span>$(m_3-m_1)^2 = 0 ∴ t = tSmol$</span></li><li><code>uSmol::Float64</code> : <span>$u - uBig$</span></li><li><code>uBig::Float64</code> : <span>$(m_2-m_3)^2 = 1 ∴ u = uSmol + 1$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/DifferentialCrossSectionFunctions.jl#L176-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho-NTuple{6, Float64}" href="#BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho-NTuple{6, Float64}"><code>BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dsigmadt_ElePosPhoPho(sSmol,sBig,tSmol,tBig,uSmol,uBig)</code></pre><p>returns the differential cross section for electron positron annihilation to two photons. Berestetskii 1982 (88.4). Masses and momenta are normalised by the rest mass of the electron <span>$m_{\text{Ele}}$</span> and the cross section is normalised by <span>$σ_T$</span>.</p><p class="math-container">\[\frac{dσ_{e^+e^-\rightarrow\gamma\gamma}}{dt} = -\frac{3}{s(s-4)}\left(\left(\frac{1}{t-1}+\frac{1}{u-1}\right)^2+\left(\frac{1}{t-1}+\frac{1}{u-1}\right)-\frac{1}{4}\left(\frac{t-1}{u-1}+\frac{u-1}{t-1}\right)\right)\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : <span>$s - sBig$</span></li><li><code>sBig::Float64</code> : <span>$(m_1+m_2)^2 = 4 ∴ s = sSmol + 4$</span></li><li><code>tSmol::Float64</code> : <span>$t - tBig$</span></li><li><code>tBig::Float64</code> : <span>$(m_3-m_1)^2 = 1 ∴ t = tSmol + 1$</span></li><li><code>uSmol::Float64</code> : <span>$u - uBig$</span></li><li><code>uBig::Float64</code> : <span>$(m2-m3)^2 = 1 ∴ u = uSmol + 1$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/DifferentialCrossSectionFunctions.jl#L66-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos-NTuple{6, Float64}" href="#BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos-NTuple{6, Float64}"><code>BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dsigmadt_PhoPhoElePos(sSmol,sBig,tSmol,tBig,uSmol,uBig)</code></pre><p>returns the differential cross section for photon-photon annihilation to electron-positron pair. (Inverse proceess of electron positron annihilation to two photons). Masses and momenta are normalised by the rest mass of the electron <span>$m_{\text{Ele}}$</span> and the cross section is normalised by <span>$σ_T$</span>.</p><p class="math-container">\[\frac{dσ_{\gamma\gamma\rightarrow e^+e^-}}{dt} = -\frac{3}{s^2}\left(\left(\frac{1}{t-1}+\frac{1}{u-1}\right)^2+\left(\frac{1}{t-1}+\frac{1}{u-1}\right)-\frac{1}{4}\left(\frac{t-1}{u-1}+\frac{u-1}{t-1}\right)\right)\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : <span>$s - sBig$</span></li><li><code>sBig::Float64</code> : <span>$(m_1+m_2)^2 = 0 ∴ s = sSmol$</span></li><li><code>tSmol::Float64</code> : <span>$t - tBig$</span></li><li><code>tBig::Float64</code> : <span>$(m_3-m_1)^2 = 1 ∴ t = tSmol + 1$</span></li><li><code>uSmol::Float64</code> : <span>$u - uBig$</span></li><li><code>uBig::Float64</code> : <span>$(m_2-m_3)^2 = 1 ∴ u = uSmol + 1$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/DifferentialCrossSectionFunctions.jl#L122-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph-NTuple{6, Float64}" href="#BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph-NTuple{6, Float64}"><code>BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dsigmadt_SphSphSphSph(sSmol,sBig,tSmol,tBig,uSmol,uBig)</code></pre><p>returns the differential cross section for the binary interaction of hard spheres with normalised masses <span>$m_1,m_2,m_3,m_4=m_{\text{Sph}}$</span>. Normalised by <span>$πR_{Sph}^2$</span>.</p><p class="math-container">\[\frac{dσ}{dt} = \frac{1}{s-4m_{\text{Sph}}^2}\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : <span>$s - sBig$</span></li><li><code>sBig::Float64</code> : <span>$(m_1+m_2)^2=4m_{\text{Sph}}^2$</span></li><li><code>tSmol::Float64</code> : <span>$t - tBig$</span></li><li><code>tBig::Float64</code> : <span>$(m_3-m_1)^2=0$</span></li><li><code>uSmol::Float64</code> : <span>$u - uBig$</span></li><li><code>uBig::Float64</code> : <span>$(m_2-m_3)^2=0$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/DifferentialCrossSectionFunctions.jl#L12-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.fload_All-Tuple{String, String}" href="#BoltzmannCollisionIntegral.fload_All-Tuple{String, String}"><code>BoltzmannCollisionIntegral.fload_All</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fload_All(fileLocation,fileName)</code></pre><p>Loads all the data stored in <code>fileName</code> stored at <code>fileLocation</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">    (Parameters,SAtot3,SAtot4,TAtot,SAtal3,SAtal4,TAtal,SMatrix3,SMatrix4,TMatrix1,TMatrix2,p3Max,p4Max,u3MinMax,u4MinMax,SConv3,SConv4,TConv) = fload_All(fileLocation,fileName);</code></pre><p>Returns a tuple of the data stored in the file. The fields are as follows:</p><ul><li><code>Parameters</code> : A tuple of the parameters used in the evaluation.</li><li><code>Stot3</code> : A 6D matrix totalling all the emission spectrum values sampled for 12-&gt;34 interaction.</li><li><code>Stot4</code> : A 6D matrix totalling all the emission spectrum values sampled for 12-&gt;43 interaction.</li><li><code>Ttot</code> : A 4D matrix totalling all the absorption spectrum values sampled.</li><li><code>Stal3</code> : A 5D matrix of tallies of the number of emission spectrum values sampled for 12-&gt;34 interaction.</li><li><code>Stal4</code> : A 5D matrix of tallies of the number of emission spectrum values sampled for 12-&gt;43 interaction.</li><li><code>Ttal</code> : A 4D matrix of tallies of the number of absorption spectrum values sampled.</li><li><code>SMatrix3</code> : A 6D matrix of the emission spectrum for 12-&gt;34 interaction.</li><li><code>SMatrix4</code> : A 6D matrix of the emission spectrum for 12-&gt;43 interaction.</li><li><code>TMatrix1</code> : A 4D matrix of the absorption spectrum for 12-&gt;34 interaction.</li><li><code>TMatrix2</code> : A 4D matrix of the absorption spectrum for 21-&gt;34 interaction i.e. by permutation of TMatrix1 and correct application of phase space factors if species 1 != species 2.</li><li><code>p3Max</code> : The maximum value of the momentum space variable p3 sampled for each bin. (Useful for correcting numerical diffusion)</li><li><code>u3MinMax</code> : The minimum and maximum values of the momentum space variable t3 sampled for each bin. (Useful for correcting numerical diffusion)</li><li><code>p4Max</code> : The maximum value of the momentum space variable p4 sampled for each bin. (Useful for correcting numerical diffusion)</li><li><code>u4MinMax</code> : The minimum and maximum values of the momentum space variable t4 sampled for each bin. (Useful for correcting numerical diffusion)</li><li><code>SConv3</code> : A 6D matrix of the convergence of the emission spectrum compared to the previous run with given <code>Parameters</code> for 12-&gt;34 interaction.</li><li><code>SConv4</code> : A 6D matrix of the convergence of the emission spectrum compared to the previous run with given <code>Parameters</code> for 12-&gt;43 interaction.</li><li><code>TConv</code> : A 4D matrix of the convergence of the absorption spectrum compared to the previous run with given <code>Parameters</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/DataReading.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.fload_All_Sync-Tuple{String, String}" href="#BoltzmannCollisionIntegral.fload_All_Sync-Tuple{String, String}"><code>BoltzmannCollisionIntegral.fload_All_Sync</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fload_All_Sync(fileLocation,fileName)</code></pre><p>Loads all the data stored in <code>fileName</code> stored at <code>fileLocation</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">    (Run_Parameters,SAtot,SAtal,SMatrix,#=pMax,tMinMax,=#SConv) = fload_All_Sync(fileLocation,fileName);</code></pre><p>Returns a tuple of the data stored in the file. The fields are as follows:</p><ul><li><code>Run_Parameters</code> : A tuple of the parameters used in the evaluation.</li><li><code>Stot</code> : A 4D matrix totalling all the synchrotron emission spectrum values</li><li><code>Stal</code> : A 4D matrix of tallies of the number of synchrotron emission spectrum values sampled</li><li><code>SMatrix</code> : A 4D matrix of the synchrotron emission spectrum.</li><li><code>pMax</code> : The maximum value of the momentum space variable p1 (photon mommentum) sampled for each bin. (Useful for correcting numerical diffusion)</li><li><code>tMinMax</code> : The minimum and maximum values of the momentum space variable t1 sampled for each bin. (Useful for correcting numerical diffusion)</li><li><code>SConv</code> : A 4D matrix of the convergence of the synchrotron emission spectrum compared to the previous run with given <code>Run_Parameters</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Synchrotron/Common/SyncDataReading.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.fload_Matrix-Tuple{String, String}" href="#BoltzmannCollisionIntegral.fload_Matrix-Tuple{String, String}"><code>BoltzmannCollisionIntegral.fload_Matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fload_Matrix(fileLocation,fileName)</code></pre><p>Loads just the S and T Matrices stored in <code>fileName</code> stored at <code>fileLocation</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">    Matrices = fload_All(fileLocation,fileName);</code></pre><p>Returns a tuple of the data stored in the file. The fields are as follows:</p><ul><li><code>Parameters</code> : A tuple of the parameters used in the evaluation.</li><li><code>SMatrix3</code> : A 6D matrix of the emission spectrum for 12-&gt;34 interaction.</li><li><code>SMatrix4</code> : A 6D matrix of the emission spectrum for 12-&gt;43 interaction.</li><li><code>TMatrix1</code> : A 4D matrix of the absorption spectrum for 12-&gt;34 interaction.</li><li><code>TMatrix2</code> : A 4D matrix of the absorption spectrum for 21-&gt;34 interaction.</li></ul><p>If initial or final particles are identical then only one of the SMatrices or TMatrices will be returned for that state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/DataReading.jl#L70-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.fload_Matrix_ISO-Tuple{String, String}" href="#BoltzmannCollisionIntegral.fload_Matrix_ISO-Tuple{String, String}"><code>BoltzmannCollisionIntegral.fload_Matrix_ISO</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fload_Matrix_ISO(fileLocation,fileName)</code></pre><p>Loads just the S and T Matrices stored in <code>fileName</code> stored at <code>fileLocation</code> first converting them to an isotropic form by summing over angles. (The dimensions of the matrices stay the same i.e. 6D-&gt;6D with three dimensions having a size of 1)</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">    Matrices = fload_All_ISO(fileLocation,fileName);</code></pre><p>Returns a tuple of the data stored in the file. The fields are as follows:</p><ul><li><code>Parameters</code> : A tuple of the parameters used in the evaluation.</li><li><code>SMatrix3</code> : A 6D matrix of the emission spectrum for 12-&gt;34 interaction.</li><li><code>SMatrix4</code> : A 6D matrix of the emission spectrum for 12-&gt;43 interaction.</li><li><code>TMatrix1</code> : A 4D matrix of the absorption spectrum for 12-&gt;34 interaction.</li><li><code>TMatrix2</code> : A 4D matrix of the absorption spectrum for 21-&gt;34 interaction.</li></ul><p>If initial or final particles are identical then only one of the SMatrices or TMatrices will be returned for that state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/DataReading.jl#L125-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.fload_Matrix_Sync-Tuple{String, String}" href="#BoltzmannCollisionIntegral.fload_Matrix_Sync-Tuple{String, String}"><code>BoltzmannCollisionIntegral.fload_Matrix_Sync</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fload_Matrix_Sync(fileLocation,fileName)</code></pre><p>Loads just the S and T Matricies stored in <code>fileName</code> stored at <code>fileLocation</code>. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">    Matricies = fload_Matrix_Sync(fileLocation,fileName);</code></pre><p>Returns a tuple of the data stored in the file. The fields are as follows:</p><ul><li><code>SMatrix</code> : A 4D matrix of the emission spectrum for Synchrotron.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Synchrotron/Common/SyncDataReading.jl#L44-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.fload_Matrix_SyncISO-Tuple{String, String}" href="#BoltzmannCollisionIntegral.fload_Matrix_SyncISO-Tuple{String, String}"><code>BoltzmannCollisionIntegral.fload_Matrix_SyncISO</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fload_Matrix_SyncISO(fileLocation,fileName)</code></pre><p>Loads just the S and T Matricies stored in <code>fileName</code> stored at <code>fileLocation</code> first converting them to an isotropic form by summing over angles. (The dimensions of the matricies stay the same i.e. 6D-&gt;6D with three dimensions having a size of 1)</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">    Matricies = fload_Matrix_SyncISO(fileLocation,fileName);</code></pre><p>Returns a tuple of the data stored in the file. The fields are as follows:</p><ul><li><code>SMatrix</code> : A 4D matrix of the emission spectrum for Synchrotron.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Synchrotron/Common/SyncDataReading.jl#L74-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.location-Tuple{Float64, Float64, Int64, Float64, String}" href="#BoltzmannCollisionIntegral.location-Tuple{Float64, Float64, Int64, Float64, String}"><code>BoltzmannCollisionIntegral.location</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">location(low_bound,up_bound,num,val,spacing)</code></pre><p>Returns the index of the bin in which &#39;val&#39; is contained based the grid bounds of that variable with &#39;num&#39; bins.</p><p>Implemented grid spacing types are:     - uniform spacing: <code>spacing = &quot;u&quot;</code>     - log10 spacing: <code>spacing = &quot;l&quot;</code>         - up and low bounds should be supplied as log10 values     - binary (1/2^n) spacing: <code>spacing = &quot;b&quot;</code>          - binary spacing is used for u=cos(theta) grids and therefore bounds should always be [-1 1] and num must be odd!</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; location(0e0,10e0,9,2e0,&quot;u&quot;)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/Location.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.location_p-Tuple{Float64, Float64, Int64, Float64}" href="#BoltzmannCollisionIntegral.location_p-Tuple{Float64, Float64, Int64, Float64}"><code>BoltzmannCollisionIntegral.location_p</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">location_p(u,l,num,val)</code></pre><p>Returns the index of the momentum bin in which &#39;val&#39; is contatined based on the &#39;num&#39; of bins and their &#39;u&#39; upper and &#39;l&#39; lower bound including overflow and underflow possibilities. Overflow are assigned to num+1 while underflow are assigned to lowest bin i.e. 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; location_p(10e0,1e0,9,2e0)
2
julia&gt; location_p(10e0,1e0,9,11e0) # overflow
10
julia&gt; location_p(10e0,1e0,9,0.5e0) # underflow
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/Location.jl#L85-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.location_t-Tuple{Int64, Float64}" href="#BoltzmannCollisionIntegral.location_t-Tuple{Int64, Float64}"><code>BoltzmannCollisionIntegral.location_t</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">location_t(numt,val)</code></pre><p>Returns the index of the bin in which the costheta &#39;val&#39; is contatined based on the &#39;numt&#39; of bins. Bounds [tl tu] are defined as CONST in Init.jl</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; location_t(8,0.5e0)
6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/Location.jl#L69-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.meanVector-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64}" href="#BoltzmannCollisionIntegral.meanVector-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64}"><code>BoltzmannCollisionIntegral.meanVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">meanVector(valr)</code></pre><p>Inputs a <code>num+1</code> long <code>Vector{Float}</code> of domain bounds and returns a <code>num</code> long <code>Vector{Float}</code> of mean value in domain range.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; meanVector([1.0e0, 10.0e0, 100.0e0, 1000.0e0])
3-element Vector{Float64}:
 5.5
 55.0
 550.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/UsefulGridValueFunctions.jl#L109-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.p4Vector!-NTuple{4, Vector{Float64}}" href="#BoltzmannCollisionIntegral.p4Vector!-NTuple{4, Vector{Float64}}"><code>BoltzmannCollisionIntegral.p4Vector!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">p4Vector!(p4v,p3v,p1v,p2v)</code></pre><p>Returns the p4 vector (in standard form [p,cos(theta),phi/pi]) given the p1, p2 and p3 vectors using conservation of momentum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/Momentum3Values.jl#L209-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.sCheck-NTuple{6, Float64}" href="#BoltzmannCollisionIntegral.sCheck-NTuple{6, Float64}"><code>BoltzmannCollisionIntegral.sCheck</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sCheck(sSmol,sBig,mu3,mu4)</code></pre><p>Returns &#39;true&#39; if &#39;s&#39; mandelstram generated from inital system state can generate a physical output state. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/MandelstramChecks.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.sigma_ElePhoElePho-Tuple{Float64, Float64}" href="#BoltzmannCollisionIntegral.sigma_ElePhoElePho-Tuple{Float64, Float64}"><code>BoltzmannCollisionIntegral.sigma_ElePhoElePho</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sigma_ElePhoElePho(sSmol,sBig)</code></pre><p>returns the total cross section for electron-photon (Compton) scattering. Berestetskii 1982 (86.16). Masses and momenta are normalised by the rest mass of the electron <span>$m_{\text{Ele}}$</span> and the cross section is normalised by <span>$σ_T$</span>.</p><p class="math-container">\[\sigma_{e\gamma\rightarrow e\gamma}(s)=\frac{3}{4(s-1)}\left[(1-\frac{4}{\left(s-1\right)}-\frac{8m_e^4}{\left(s-1\right)^2})\log\left(s\right)+\frac{1}{2}+\frac{8}{s-1}-\frac{1}{2s^2}\right]\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : <span>$s - sBig$</span></li><li><code>sBig::Float64</code> : <span>$(m_1+m_2)^2 = 1 ∴ s = sSmol + 1$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/DifferentialCrossSectionFunctions.jl#L205-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.sigma_ElePosPhoPho-Tuple{Float64, Float64}" href="#BoltzmannCollisionIntegral.sigma_ElePosPhoPho-Tuple{Float64, Float64}"><code>BoltzmannCollisionIntegral.sigma_ElePosPhoPho</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sigma_ElePosPhoPho(sSmol,sBig)</code></pre><p>returns the total cross section for electron positron annihilation to two photons. Berestetskii 1982 (88.6). Masses and momenta are normalised by the rest mass of the electron <span>$m_{\text{Ele}}$</span> and the cross section is normalised by <span>$σ_T$</span>.</p><p class="math-container">\[σ_{e^+e^-\rightarrow\gamma\gamma} = \frac{3}{4s^2(s-4)}\left((s^2+4s-8)\log\left(\frac{\sqrt{s}+\sqrt{s-4}}{\sqrt{s}-\sqrt{s-4}}\right)-(s+4)\sqrt{s(s-4)}\right)\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : <span>$s - sBig$</span></li><li><code>sBig::Float64</code> : <span>$(m_1+m_2)^2 = 4 ∴ s = sSmol + 4$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/DifferentialCrossSectionFunctions.jl#L92-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.sigma_PhoPhoElePos-Tuple{Float64, Float64}" href="#BoltzmannCollisionIntegral.sigma_PhoPhoElePos-Tuple{Float64, Float64}"><code>BoltzmannCollisionIntegral.sigma_PhoPhoElePos</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sigma_PhoPhoElePos(sSmol,sBig)</code></pre><p>returns the total cross section for photon-photon annihilation to electron-positron pair. Masses and momenta are normalised by the rest mass of the electron <span>$m_{\text{Ele}}$</span> and the cross section is normalised by <span>$σ_T$</span>.</p><p class="math-container">\[σ_{\gamma\gamma\rightarrow e^+e^-} = \frac{3}{2s^3}\left((s^2+4s-8)\log\left(\frac{\sqrt(s)+\sqrt(s-4)}{\sqrt(s)-\sqrt(s-4)}\right)-(s+4)\sqrt{s(s-4)}\right)\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : <span>$s - sBig$</span></li><li><code>sBig::Float64</code> : <span>$(m_1+m_2)^2 = 0 ∴ s = sSmol$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/DifferentialCrossSectionFunctions.jl#L147-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.sigma_SphSphSphSph-Tuple{Float64, Float64}" href="#BoltzmannCollisionIntegral.sigma_SphSphSphSph-Tuple{Float64, Float64}"><code>BoltzmannCollisionIntegral.sigma_SphSphSphSph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sigma_SphSphSphSph(sSmol,sBig)</code></pre><p>returns the total cross section for the binary interaction of hard spheres with normalised masses (wrt electron mass) <span>$m_1,m_2,m_3,m_4=m_\text{Sph}$</span>. Normalised by <span>$πR_{Sph}^2$</span>.</p><p class="math-container">\[σ = \frac{1}{2}\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : s - sBig</li><li><code>sBig::Float64</code> : (m1+m2)^2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/DifferentialCrossSectionFunctions.jl#L40-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.vectorLocation-Tuple{Float64, Float64, Int64, Int64, Vector{Float64}}" href="#BoltzmannCollisionIntegral.vectorLocation-Tuple{Float64, Float64, Int64, Int64, Vector{Float64}}"><code>BoltzmannCollisionIntegral.vectorLocation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vectorLocation(pu,pl,nump,numt,vector)</code></pre><p>Returns a tuple of bin location for (log10momentum,cos(theta)) based on an input &#39;vector&#39; and bounds &#39;u,l&#39; of their domains and the &#39;num&#39; of uniformly spaced bins. costheta bounds [tl tu] are defined as CONST in Init.jl</p><p><strong>Examples</strong></p><p>```julia-repl julia&gt; vectorLocation(4e0,-5e0,9,8,[1e0,0.5e0,1.5e0]) (5,6)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/224ec7ac89a380ab8e11cf344e7015e790e4d687/src/Common/Location.jl#L107-L117">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../synchrotron/">« Synchrotron Emissions</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Friday 31 January 2025 17:31">Friday 31 January 2025</span>. Using Julia version 1.10.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
