<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internal Functions · BoltzmannCollisionIntegral.jl</title><meta name="title" content="Internal Functions · BoltzmannCollisionIntegral.jl"/><meta property="og:title" content="Internal Functions · BoltzmannCollisionIntegral.jl"/><meta property="twitter:title" content="Internal Functions · BoltzmannCollisionIntegral.jl"/><meta name="description" content="Documentation for BoltzmannCollisionIntegral.jl."/><meta property="og:description" content="Documentation for BoltzmannCollisionIntegral.jl."/><meta property="twitter:description" content="Documentation for BoltzmannCollisionIntegral.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="BoltzmannCollisionIntegral.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="BoltzmannCollisionIntegral.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">BoltzmannCollisionIntegral.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../quickstart/">Getting Started</a></li><li><a class="tocitem" href="../crosssections/">Cross Sections</a></li><li class="is-active"><a class="tocitem" href>Internal Functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Internal Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internal Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/main/docs/src/internalfunctions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal-Functions"><a class="docs-heading-anchor" href="#Internal-Functions">Internal Functions</a><a id="Internal-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.InvarientFlux-Tuple{Float32, Float32, Float32}" href="#BoltzmannCollisionIntegral.InvarientFlux-Tuple{Float32, Float32, Float32}"><code>BoltzmannCollisionIntegral.InvarientFlux</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InvarientFlux(s,mu12,mu22)</code></pre><p>returns the value of the invarient flux with &#39;s&#39; mandelstram variable and masses &#39;mass1&#39; and &#39;mass2&#39;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/STValue.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.InvarientFlux2-Tuple{Float32, Float32, Float32}" href="#BoltzmannCollisionIntegral.InvarientFlux2-Tuple{Float32, Float32, Float32}"><code>BoltzmannCollisionIntegral.InvarientFlux2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InvarientFlux2(s,mass12,mass22)</code></pre><p>returns the value of the squared invarient flux with &#39;s&#39; mandelstram variable and masses &#39;mass1&#39; and &#39;mass2&#39;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/STValue.jl#L181-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.InvarientFlux2Small-Tuple{Float32, Float32, Float32}" href="#BoltzmannCollisionIntegral.InvarientFlux2Small-Tuple{Float32, Float32, Float32}"><code>BoltzmannCollisionIntegral.InvarientFlux2Small</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InvarientFluxSmall(sSmol,mass12,mass22)</code></pre><p>returns the value of the squared invarient flux with smalled &#39;s&#39; mandelstram variable (sSmol = s - (m1+m2)^2)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/STValue.jl#L193-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.InvarientFluxSmall-Tuple{Float32, Float32, Float32}" href="#BoltzmannCollisionIntegral.InvarientFluxSmall-Tuple{Float32, Float32, Float32}"><code>BoltzmannCollisionIntegral.InvarientFluxSmall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InvarientFluxSmall(sSmol,mu12,mu22)</code></pre><p>returns the value of the invarient flux with smalled &#39;s&#39; mandelstram variable (sSmol = s - (m1+m2)^2)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/STValue.jl#L168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.Momentum3Value!-Tuple{Vector{Float32}, Vector{Float32}, Vector{Float32}, Vector{Float32}, Vararg{Float32, 4}}" href="#BoltzmannCollisionIntegral.Momentum3Value!-Tuple{Vector{Float32}, Vector{Float32}, Vector{Float32}, Vector{Float32}, Vararg{Float32, 4}}"><code>BoltzmannCollisionIntegral.Momentum3Value!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Momentum3Value!(p3v,p3pv,p1v,p2v)</code></pre><p>Takes set of random initial particle states &#39;p1v&#39; and &#39;p2v&#39; and random output states angles &#39;p3v[2:3]&#39; and modifies outputs &#39;p3v&#39; and &#39;p3pv&#39; values with calculated output momentum and corrects angles if momentum is negative. Function also returns a two bools &#39;p3<em>physical&#39; and &#39;p3p</em>physical&#39; indicating if p3 and p3p are physical momentum states given the inputs.  Function also returns a Int &#39;NumStates&#39; indicating the number of valid output states found.</p><p>Requrires normalised masses (mu1,mu2,mu3,mu4) to be defined in advance in Init.jl as const.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mu1 = 1836.1528f0
julia&gt; mu2 = 1836.1528f0
julia&gt; mu3 = 1836.1528f0
julia&gt; mu4 = 1836.1528f0
julia&gt; p1v = [1f0, 0.5f0, 1.8f0]
julia&gt; p2v = [2f0, 0.2f0, 0.7f0]
julia&gt; p3v = [0f0, 0.3f0, 0.7f0]
julia&gt; p3pv = zeros(Float32,3)
julia&gt; p3pv .= p3v
julia&gt; Momentum3Value!(p3v,p3pv,p1v,p2v,mu1,mu2,mu3,mu4)
(true,true,2)
julia&gt; p3v
 3-element Vector{Float32}:
 2.04505
 0.3
 0.7
julia&gt; p3pv
 3-element Vector{Float32}
 0.691423
 -0.3
 1.7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/Momentum3Values.jl#L2-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.PhaseSpaceFactors1!-Tuple{Array{Float32, 6}, Array{Float32, 4}, Vector{Float32}, Vector{Float32}, Vector{Float32}, Vector{Float32}, Vector{Float32}, String, String}" href="#BoltzmannCollisionIntegral.PhaseSpaceFactors1!-Tuple{Array{Float32, 6}, Array{Float32, 4}, Vector{Float32}, Vector{Float32}, Vector{Float32}, Vector{Float32}, Vector{Float32}, String, String}"><code>BoltzmannCollisionIntegral.PhaseSpaceFactors1!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PhaseSpaceFactors1!(SMatrix,TMatrix,t3val,p1val,t1val,p2val,t2val,name1,name2)</code></pre><p>Applies phase space volume element factors for &#39;SMatrix&#39; and &#39;TMatrix&#39; terms in order to correctly apply &#39;STSymmetry&#39; corrections. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/PhaseSpaceFactors.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.PhaseSpaceFactors2!-Tuple{Array{Float32, 6}, Array{Float32, 4}, Vararg{Vector{Float32}, 4}}" href="#BoltzmannCollisionIntegral.PhaseSpaceFactors2!-Tuple{Array{Float32, 6}, Array{Float32, 4}, Vararg{Vector{Float32}, 4}}"><code>BoltzmannCollisionIntegral.PhaseSpaceFactors2!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PhaseSpaceFactors2!(SMatrix,TMatrix,t3val,p1val,t1val,p2val,t2val)</code></pre><p>To follow &#39;PhaseSpaceFactors1&#39; and &#39;STSymmetry&#39;. Corrects phase space factors on &#39;SMatrix&#39; and &#39;TMatrix&#39; for use in kinetic codes. Assumes f(x,p,μ)= constant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/PhaseSpaceFactors.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.RPointLogMomentum!-Tuple{Vector{Float32}, Float32, Float32, Int64}" href="#BoltzmannCollisionIntegral.RPointLogMomentum!-Tuple{Vector{Float32}, Float32, Float32, Int64}"><code>BoltzmannCollisionIntegral.RPointLogMomentum!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RPointLogMomentum!(pu,pl,pv,num)</code></pre><p>Edits the first element of <code>pv</code> with a random real-space momentum value between <span>$10^{pl}$</span> and <span>$10^{pu}$</span>. This sample is chosen by first randomly picking a momentum bin in the range <code>1:num</code> and then uniformly sampling a momentum point in real-space (rather than log10 space) between pl and pu which are the momentum values at start and end of that bin. Sampling is done such there will be a constant number of points per momentum-space volume. As the momentum space between <span>$10^{pl}$</span> and <span>$10^{pu}$</span> it is a spherical shell hence the correct sampling is <span>$p = (U*(10^{pu})^3+(1-U)*(10^{pl})^3)^{1/3}$</span> with uniform <span>$U ∈ [0~~1]$</span>.</p><p>Assumes <span>$f(x,p,μ)=f(x,\vec{p})*(2πp^2)=const$</span> in bin, therefore momentum space volume element is <span>$\mathrm{d}p$</span> and as such uniform sampling corresponds to <span>$U*10^{u}+(1-U)*10^{l}$</span> where <span>$U$</span> is a uniform random number between 0 and 1.</p><p>If instead <span>$f(x,\vec{p})=const$</span> in bin, momentum space volume element is <span>$p^2 \mathrm{d}p$</span> and uniform sampling corresponds to <span>$(10^pu)*\sqrt[3]{U+(1-U)*10^{3pl-3pu}}$</span> where <span>$U$</span> is a uniform random number between 0 and 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/RandomPoints.jl#L5-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.RPointSphereCosThetaPhi!-Tuple{Vector{Float32}}" href="#BoltzmannCollisionIntegral.RPointSphereCosThetaPhi!-Tuple{Vector{Float32}}"><code>BoltzmannCollisionIntegral.RPointSphereCosThetaPhi!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RPointSphereThetaPhi!()</code></pre><p>Assigns the second (cos(theta)) and third (phi) elements of &#39;a&#39; with a randomly, uniformly sampled values of spherical angles cos(theta) and phi (phi normalised by pi). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/RandomPoints.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.STMonteCarloAxi_MultiThread!-Tuple{Array{Float32, 6}, Array{Float32, 4}, Array{UInt32, 5}, Array{UInt32, 4}, Any, Array{Float32, 5}, Array{Float32, 6}, Function, Function, Tuple{Float32, Float32, Float32, Float32, Float32, Float32, Int64, Float32, Float32, Int64, Float32, Float32, Vararg{Int64, 4}}, Int64, Int64}" href="#BoltzmannCollisionIntegral.STMonteCarloAxi_MultiThread!-Tuple{Array{Float32, 6}, Array{Float32, 4}, Array{UInt32, 5}, Array{UInt32, 4}, Any, Array{Float32, 5}, Array{Float32, 6}, Function, Function, Tuple{Float32, Float32, Float32, Float32, Float32, Float32, Int64, Float32, Float32, Int64, Float32, Float32, Vararg{Int64, 4}}, Int64, Int64}"><code>BoltzmannCollisionIntegral.STMonteCarloAxi_MultiThread!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">STMonteCarloAxi_MultiThread!(SAtotal,TAtotal,SAtally,TAtally,p3v,p3pv,p1v,p2v,p3Max,t3MinMax,sigma,dsigmadt,Parameters,numTiterPerThread,numSiterPerThread)</code></pre><p><strong>Arguments</strong></p><ul><li><code>SAtotal::Array{Float32,6}</code> : Array of stored integration totals for S matrix</li><li><code>TAtotal::Array{Float32,4}</code> : Array of stored integration totals for T matrix</li><li><code>SAtally::Array{UInt32,5}</code> : Array of stored integration tallies for S matrix</li><li><code>TAtally::Array{UInt32,4}</code> : Array of stored integration tallies for T matrix</li><li><code>p3v::Vector{Float32}</code> : Vector of momentum values for species 3</li><li><code>p3pv::Vector{Float32}</code> : Second Vector of momentum values for species 3 for when two states are possible</li><li><code>p1v::Vector{Float32}</code> : Vector of momentum values for species 1</li><li><code>p2v::Vector{Float32}</code> : Vector of momentum values for species 2</li><li><code>p3Max::Array{Float32,5}</code> : Array of maximum momentum values for species 3</li><li><code>t3MinMax::Array{Float32,6}</code> : Array of minimum and maximum theta values for species 3</li><li><code>sigma::Function</code> : Cross section function for the interaction</li><li><code>dsigmadt::Function</code> : Differential cross section function for the interaction</li><li><code>Parameters::Tuple{Float32,Float32,Float32,Float32,Float32,Float32,Int64,Float32,Float32,Int64,Float32,Float32,Int64,Int64,Int64,Int64}</code> : Tuple of parameters for the interaction</li><li><code>numTiterPerThread::Int64</code> : Number of T iterations per thread</li><li><code>numSiterPerThread::Int64</code> : Number of S iterations per thread</li></ul><p><strong>Output:</strong></p><ul><li>Argument arrays SAtotal,TAtotal,SAtally,TAtally are mutated to include the results of the Monte Carlo Integration.</li></ul><p><strong>Hidden Inputs (defined in Init.jl)</strong></p><ul><li>Domain Boundaries (defined as CONST)       - p bounds and divisions for species 1,3,4       - theta divisions for species 1,3,4 ( bounds not needed as assumed [-1,1] )       - phi divisions for species 1,3,4 ( bounds not needed as assumed [0,2] )</li><li>Particle Masses (defined as CONST)</li><li>numTiterPerThread and numSiterPerThread as the number of T and S integrations to perform.</li></ul><p><strong>Calculation In Breif</strong></p><ul><li>Set up worker threads</li><li>Random Sample points in each of these domains<ul><li>RandomPointSphere for theta and phi (for species 1,2,3)</li><li>RandomPointMomentum for p ( species 1,2 only )</li></ul></li><li>Take random points (t3,h1,p1,p2,t1,t2,h3,h4) and calculate valid p3 point/points </li><li>Find position in local S and T arrays and allocated tallies and totals accordingly.</li><li>Update global S and T arrays with locks to prevent data races</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/MultiThread/STMonteCarlo_MultiThread.jl#L6-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.STMonteCarloAxi_Serial!-Tuple{Array{Float32, 6}, Array{Float32, 4}, Array{UInt32, 5}, Array{UInt32, 4}, Vector{Float32}, Vector{Float32}, Vector{Float32}, Vector{Float32}, Array{Float32, 5}, Array{Float32, 6}, Function, Function, Tuple{Float32, Float32, Float32, Float32, Float32, Float32, Int64, Float32, Float32, Int64, Float32, Float32, Vararg{Int64, 4}}, Int64, Int64}" href="#BoltzmannCollisionIntegral.STMonteCarloAxi_Serial!-Tuple{Array{Float32, 6}, Array{Float32, 4}, Array{UInt32, 5}, Array{UInt32, 4}, Vector{Float32}, Vector{Float32}, Vector{Float32}, Vector{Float32}, Array{Float32, 5}, Array{Float32, 6}, Function, Function, Tuple{Float32, Float32, Float32, Float32, Float32, Float32, Int64, Float32, Float32, Int64, Float32, Float32, Vararg{Int64, 4}}, Int64, Int64}"><code>BoltzmannCollisionIntegral.STMonteCarloAxi_Serial!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">STMonteCarloAxi_Serial!(SAtotal,TAtotal,SAtally,TAtally,p3v,p3pv,p1v,p2v,p3Max,t3MinMax,sigma,dsigmadt,Parameters,numTiter,numSiter)</code></pre><p><strong>Arguments</strong></p><ul><li><code>SAtotal::Array{Float32,6}</code> : Array of stored integration totals for S matrix</li><li><code>TAtotal::Array{Float32,4}</code> : Array of stored integration totals for T matrix</li><li><code>SAtally::Array{UInt32,5}</code> : Array of stored integration tallies for S matrix</li><li><code>TAtally::Array{UInt32,4}</code> : Array of stored integration tallies for T matrix</li><li><code>p3v::Vector{Float32}</code> : Vector of momentum values for species 3</li><li><code>p3pv::Vector{Float32}</code> : Second Vector of momentum values for species 3 for when two states are possible</li><li><code>p1v::Vector{Float32}</code> : Vector of momentum values for species 1</li><li><code>p2v::Vector{Float32}</code> : Vector of momentum values for species 2</li><li><code>p3Max::Array{Float32,5}</code> : Array of maximum momentum values for species 3</li><li><code>t3MinMax::Array{Float32,6}</code> : Array of minimum and maximum theta values for species 3</li><li><code>sigma::Function</code> : Cross section function for the interaction</li><li><code>dsigmadt::Function</code> : Differential cross section function for the interaction</li><li><code>Parameters::Tuple{Float32,Float32,Float32,Float32,Float32,Float32,Int64,Float32,Float32,Int64,Float32,Float32,Int64,Int64,Int64,Int64}</code> : Tuple of parameters for the interaction</li><li><code>numTiter::Int64</code> : Number of T iterations</li><li><code>numSiter::Int64</code> : Number of S iterations</li></ul><p><strong>Output:</strong></p><ul><li>Argument arrays SAtotal,TAtotal,SAtally,TAtally are mutated to include the results of the Monte Carlo Integration.</li></ul><p><strong>Hidden Inputs (defined in Init.jl)</strong></p><ul><li>Domain Boundaries (defined as CONST)       - p bounds and divisions for species 1,3,4       - theta divisions for species 1,3,4 ( bounds not needed as assumed [-1,1] )       - phi divisions for species 1,3,4 ( bounds not needed as assumed [0,2] )</li><li>Particle Masses (defined as CONST)</li><li>numTiter and numSiter as the number of T and S integrations to perform.</li></ul><p><strong>Calculation In Breif</strong></p><ul><li>Random Sample points in each of these domains<ul><li>RandomPointSphere for theta and phi (for species 1,2,3)</li><li>RandomPointMomentum for p ( species 1,2 only )</li></ul></li><li>Take random points (t3,h1,p1,p2,t1,t2,h3,h4) and calculate valid p3 point/points </li><li>Find position in S and T arrays and allocated tallies and totals accordingly.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Serial/STMonteCarlo_Serial.jl#L6-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.STSymmetry!-Tuple{Array{Float32, 6}, Array{Float32, 4}, Float32, Float32}" href="#BoltzmannCollisionIntegral.STSymmetry!-Tuple{Array{Float32, 6}, Array{Float32, 4}, Float32, Float32}"><code>BoltzmannCollisionIntegral.STSymmetry!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">STSymmetry!(SMatrix,TMatrix,t3val,p1val,t1val,p2val,t2val,mu1,mu2)</code></pre><p>To follow &#39;PhaseSpaceFactors1&#39;. Physical nature of binary interaction has certain symmetries. &#39;STSymmetry&#39; uses these symmetries to improve MC sampling of &#39;SMatrix&#39; and &#39;TMatrix&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/PhaseSpaceFactors.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.SValue-Tuple{Vector{Float32}, Vector{Float32}, Vector{Float32}, Function, Float32, Float32, Float32}" href="#BoltzmannCollisionIntegral.SValue-Tuple{Vector{Float32}, Vector{Float32}, Vector{Float32}, Function, Float32, Float32, Float32}"><code>BoltzmannCollisionIntegral.SValue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SValue(p3v,p1v,p2v,dsigmadt,mu1,mu2,mu3)</code></pre><p>Returns <code>Sval</code> from MC integration based on initial momentum states <code>p1v</code> and <code>p2v</code> and final state <code>p3v</code> and differential cross section <code>dsigmadt</code> based on particle selection.   Assumes f(x,p,μ)=constant over bin</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/STValue.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.SpectraEvaluateMultiThread-Tuple{Tuple{String, String, String, String, Float32, Float32, Int64, Float32, Float32, Int64, Float32, Float32, Int64, Int64, Int64, Int64, Int64, Int64, Int64, String, String}}" href="#BoltzmannCollisionIntegral.SpectraEvaluateMultiThread-Tuple{Tuple{String, String, String, String, Float32, Float32, Int64, Float32, Float32, Int64, Float32, Float32, Int64, Int64, Int64, Int64, Int64, Int64, Int64, String, String}}"><code>BoltzmannCollisionIntegral.SpectraEvaluateMultiThread</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SpectraEvaluateMultiThread(userInputMultiThread)</code></pre><p>Function to run the Monte Carlo integration of the S and T arrays in a multi-threaded environment. The function will run the Monte Carlo integration in parallel across the number of threads specified in the global variable nThreads. The function will then calculate the S and T matricies and save the results to a file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/MultiThread/STIntegration_MultiThread.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.SpectraEvaluateSerial-Tuple{Tuple{String, String, String, String, Float32, Float32, Int64, Float32, Float32, Int64, Float32, Float32, Int64, Int64, Int64, Int64, Int64, Int64, String, String}}" href="#BoltzmannCollisionIntegral.SpectraEvaluateSerial-Tuple{Tuple{String, String, String, String, Float32, Float32, Int64, Float32, Float32, Int64, Float32, Float32, Int64, Int64, Int64, Int64, Int64, Int64, String, String}}"><code>BoltzmannCollisionIntegral.SpectraEvaluateSerial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SpectraEvaluateSerial(userInputSerial)</code></pre><p>Function to run the Monte Carlo integration of the S and T arrays in a serial environment. The function will run the Monte Carlo integration in serial and then calculate the S and T matricies and save the results to a file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Serial/STIntegration_Serial.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.TValue-Tuple{Vector{Float32}, Vector{Float32}, Function, Vararg{Float32, 4}}" href="#BoltzmannCollisionIntegral.TValue-Tuple{Vector{Float32}, Vector{Float32}, Function, Vararg{Float32, 4}}"><code>BoltzmannCollisionIntegral.TValue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TValue(p1v,p2v,sigma,mu1,mu2)</code></pre><p>returns <code>Tval</code> with its Tval from MC integration based on initial momentum states <code>p1v</code> and <code>p2v</code> and cross section <code>sigma</code> based on particle selection. If initial state fails <code>sCheck</code>, i.e. cannot generate a physical output state, Tval is set to 0f0.  Assumes f(x,p,μ)=constant over bin</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/STValue.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.deltaEVector-Tuple{Vector{Float32}, Float32}" href="#BoltzmannCollisionIntegral.deltaEVector-Tuple{Vector{Float32}, Float32}"><code>BoltzmannCollisionIntegral.deltaEVector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deltaEVector(pr,mu)</code></pre><p>Inputs a <code>num+1</code> long <code>Vector{Float32}</code> of p grid boundries and the particle <code>mu</code> value (normalised mass) and returns a <code>num</code> long <code>Vector{Float32}</code> of average energy values per grid cell.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; deltaEVector([1.0f0, 10.0f0, 100.0f0, 1000.0f0], 1.0f0)
3-element Vector{Float32}:
 50.600693
 4951.15
 495001.16</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/UsefulGridValueFunctions.jl#L137-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.deltaVector-Tuple{Vector{Float32}}" href="#BoltzmannCollisionIntegral.deltaVector-Tuple{Vector{Float32}}"><code>BoltzmannCollisionIntegral.deltaVector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deltaVector(valr)</code></pre><p>Inputs a <code>num+1</code> long <code>Vector{Float32}</code> quantitiy values (domain bounds) and returns a <code>num</code> long <code>Vector{Float32}</code> of differeces (domain widths).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; deltaVector([1.0f0, 10.0f0, 100.0f0, 1000.0f0])
3-element Vector{Float32}:
 9.0
 90.0
 900.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/UsefulGridValueFunctions.jl#L79-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho-NTuple{6, Float32}" href="#BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho-NTuple{6, Float32}"><code>BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dsigmadt_ElePosPhoPho(sSmol,sBig,tSmol,tBig,uSmol,uBig)</code></pre><p>returns the differential cross section for electron positron annihilation to two photons. Berestetskii 1982 (88.4). Masses and momenta are normalised by the rest mass of the electron <span>$m_{\text{Ele}}$</span> and the cross section is normalised by <span>$3σ_T$</span>.</p><p class="math-container">\[\frac{dσ}{dt} = -\frac{1}{s(s-4)}\left(\left(\frac{1}{t-1}+\frac{1}{u-1}\right)^2+\left(\frac{1}{t-1}+\frac{1}{u-1}\right)-\frac{1}{4}\left(\frac{t-1}{u-1}+\frac{u-1}{t-1}\right)\right)\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float32</code> : <span>$s - sBig$</span></li><li><code>sBig::Float32</code> : <span>$(m_1+m_2)^2 = 4 ∴ s = sSmol + 4$</span></li><li><code>tSmol::Float32</code> : <span>$t - tBig$</span></li><li><code>tBig::Float32</code> : <span>$(m_3-m_1)^2 = 1 ∴ t = tSmol + 1$</span></li><li><code>uSmol::Float32</code> : <span>$u - uBig$</span></li><li><code>uBig::Float32</code> : <span>$(m2-m3)^2 = 1 ∴ u = uSmol + 1$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/DifferentialCrossSectionFunctions.jl#L66-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos-NTuple{6, Float32}" href="#BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos-NTuple{6, Float32}"><code>BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dsigmadt_PhoPhoElePos(sSmol,sBig,tSmol,tBig,uSmol,uBig)</code></pre><p>returns the differential cross section for photon-photon annihilation to electron-positron pair. (Inverse proceess of electron positron annihilation to two photons). Masses and momenta are normalised by the rest mass of the electron <span>$m_{\text{Ele}}$</span> and the cross section is normalised by <span>$3σ_T$</span>.</p><pre><code class="language-maths hljs">\frac{dσ}{dt} = -\frac{1}{s^2}\left(\left(\frac{1}{t-1}+\frac{1}{u-1}\right)^2+\left(\frac{1}{t-1}+\frac{1}{u-1}\right)-\frac{1}{4}\left(\frac{t-1}{u-1}+\frac{u-1}{t-1}\right)\right)</code></pre><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float32</code> : <span>$s - sBig$</span></li><li><code>sBig::Float32</code> : <span>$(m_1+m_2)^2 = 0 ∴ s = sSmol$</span></li><li><code>tSmol::Float32</code> : <span>$t - tBig$</span></li><li><code>tBig::Float32</code> : <span>$(m_3-m_1)^2 = 1 ∴ t = tSmol + 1$</span></li><li><code>uSmol::Float32</code> : <span>$u - uBig$</span></li><li><code>uBig::Float32</code> : <span>$(m_2-m_3)^2 = 1 ∴ u = uSmol + 1$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/DifferentialCrossSectionFunctions.jl#L122-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph-NTuple{6, Float32}" href="#BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph-NTuple{6, Float32}"><code>BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dsigmadt_SphSphSphSph(sSmol,sBig,tSmol,tBig,uSmol,uBig)</code></pre><p>returns the differential cross section for the binary interaction of hard spheres with normalised masses <span>$m_1,m_2,m_3,m_4=m_{\text{Sph}}$</span>. Normalised by <span>$πR_{Sph}^2$</span>.</p><p class="math-container">\[\frac{dσ}{dt} = \frac{1}{s-4m_{\text{Sph}}^2}\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float32</code> : <span>$s - sBig$</span></li><li><code>sBig::Float32</code> : <span>$(m_1+m_2)^2=4m_{\text{Sph}}^2$</span></li><li><code>tSmol::Float32</code> : <span>$t - tBig$</span></li><li><code>tBig::Float32</code> : <span>$(m_3-m_1)^2=0$</span></li><li><code>uSmol::Float32</code> : <span>$u - uBig$</span></li><li><code>uBig::Float32</code> : <span>$(m_2-m_3)^2=0$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/DifferentialCrossSectionFunctions.jl#L12-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.fload_All-Tuple{String, String}" href="#BoltzmannCollisionIntegral.fload_All-Tuple{String, String}"><code>BoltzmannCollisionIntegral.fload_All</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fload_All(fileLocation,fileName)</code></pre><p>Loads all the data stored in <code>fileName</code> stored at <code>fileLocation</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">    (Run_Parameters, Stot,Ttot,Stal,Ttal,SMatrix,TMatrix,p3Max,t3MinMax,SConv,TConv) = fload_All(fileLocation,fileName);</code></pre><p>Returns a tuple of the data stored in the file. The fields are as follows:</p><ul><li><code>Run_Parameters</code> : A tuple of the parameters used in the evaluation.</li><li><code>Stot</code> : A 6D matrix totalling all the emission spectrum values sampled.</li><li><code>Ttot</code> : A 4D matrix totalling all the absorption spectrum values sampled.</li><li><code>Stal</code> : A 5D matrix of tallies of the number of emission spectrum values sampled.</li><li><code>Ttal</code> : A 4D matrix of tallies of the number of absorption spectrum values sampled.</li><li><code>SMatrix</code> : A 6D matrix of the emission spectrum.</li><li><code>TMatrix</code> : A 4D matrix of the absorption spectrum.</li><li><code>p3Max</code> : The maximum value of the momentum space variable p3 sampled for each bin. (Useful for correcting numerical diffusion)</li><li><code>t3MinMax</code> : The minimum and maximum values of the momentum space variable t3 sampled for each bin. (Useful for correcting numerical diffusion)</li><li><code>SConv</code> : A 6D matrix of the convergence of the emission spectrum compaired to the previous run with given <code>Run_Parameters</code>.</li><li><code>TConv</code> : A 4D matrix of the convergence of the absorption spectrum compaired to the previous run with given <code>Run_Parameters</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/DataReading.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.location-Tuple{Float32, Float32, Int64, Float32}" href="#BoltzmannCollisionIntegral.location-Tuple{Float32, Float32, Int64, Float32}"><code>BoltzmannCollisionIntegral.location</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">location(u,l,num,val)</code></pre><p>Returns the index of the bin in which &#39;val&#39; is contatined based on the &#39;num&#39; of bins and their &#39;u&#39; upper and &#39;l&#39; lower bound.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; location(10f0,0f0,9,2f0)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/Location.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.location_p3-Tuple{Float32, Float32, Int64, Float32}" href="#BoltzmannCollisionIntegral.location_p3-Tuple{Float32, Float32, Int64, Float32}"><code>BoltzmannCollisionIntegral.location_p3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">location_p3(u,l,num,val)</code></pre><p>Returns the index of the bin in which &#39;val&#39; is contatined based on the &#39;num&#39; of bins and their &#39;u&#39; upper and &#39;l&#39; lower bound including overflow and underflow possibilities. Overflow are assigned to num+1 while underflow are assigned to lowest bin i.e. 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; location_p3(10f0,1f0,9,2f0)
2
julia&gt; location_p3(10f0,1f0,9,11f0) # overflow
10
julia&gt; location_p3(10f0,1f0,9,0.5f0) # underflow
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/Location.jl#L33-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.location_t-Tuple{Int64, Float32}" href="#BoltzmannCollisionIntegral.location_t-Tuple{Int64, Float32}"><code>BoltzmannCollisionIntegral.location_t</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">location_t(numt,val)</code></pre><p>Returns the index of the bin in which the costheta &#39;val&#39; is contatined based on the &#39;numt&#39; of bins. Bounds [tl tu] are defined as CONST in Init.jl</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; location_t(8,0.5f0)
6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/Location.jl#L17-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.meanVector-Tuple{Vector{Float32}}" href="#BoltzmannCollisionIntegral.meanVector-Tuple{Vector{Float32}}"><code>BoltzmannCollisionIntegral.meanVector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">meanVector(valr)</code></pre><p>Inputs a <code>num+1</code> long <code>Vector{Float32}</code> of domain bounds and returns a <code>num</code> long <code>Vector{Float32}</code> of mean value in domain range.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; meanVector([1.0f0, 10.0f0, 100.0f0, 1000.0f0])
3-element Vector{Float32}:
 5.5
 55.0
 550.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/UsefulGridValueFunctions.jl#L108-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.prange-Tuple{Float32, Float32, Int64}" href="#BoltzmannCollisionIntegral.prange-Tuple{Float32, Float32, Int64}"><code>BoltzmannCollisionIntegral.prange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prange(pl,pu,nump)</code></pre><p>Returns a <code>nump+1</code> long <code>Vector{Float32}</code> of p-space grid bounds NOT in Log10 space.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; prange(-5f0,4f0,9)
10-element Vector{Float32}:
 1.0e-5
 1.0e-4
 1.0e-3
 0.01
 0.1
 1.0
 10.0
 100.0
 1000.0
 10000.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/UsefulGridValueFunctions.jl#L24-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.sCheck-NTuple{4, Float32}" href="#BoltzmannCollisionIntegral.sCheck-NTuple{4, Float32}"><code>BoltzmannCollisionIntegral.sCheck</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sCheck(sSmol,sBig,mu3,mu4)</code></pre><p>Returns &#39;true&#39; if &#39;s&#39; mandelstram generated from inital system state can generate a physical output state. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/MandelstramChecks.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.sigma_ElePosPhoPho-Tuple{Float32, Float32}" href="#BoltzmannCollisionIntegral.sigma_ElePosPhoPho-Tuple{Float32, Float32}"><code>BoltzmannCollisionIntegral.sigma_ElePosPhoPho</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sigma_ElePosPhoPho(sSmol,sBig)</code></pre><p>returns the total cross section for electron positron annihilation to two photons. Berestetskii 1982 (88.6). Masses and momenta are normalised by the rest mass of the electron <span>$m_{\text{Ele}}$</span> and the cross section is normalised by <span>$3σ_T$</span>.</p><p class="math-container">\[σ = \frac{1}{4s^2(s-4)}\left((s^2+4s-8)\log\left(\frac{\sqrt{s}+\sqrt{s-4}}{\sqrt{s}-\sqrt{s-4}}\right)-(s+4)\sqrt{s(s-4)}\right)\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float32</code> : <span>$s - sBig$</span></li><li><code>sBig::Float32</code> : <span>$(m_1+m_2)^2 = 4 ∴ s = sSmol + 4$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/DifferentialCrossSectionFunctions.jl#L92-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.sigma_PhoPhoElePos-Tuple{Float32, Float32}" href="#BoltzmannCollisionIntegral.sigma_PhoPhoElePos-Tuple{Float32, Float32}"><code>BoltzmannCollisionIntegral.sigma_PhoPhoElePos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sigma_PhoPhoElePos(sSmol,sBig)</code></pre><p>returns the total cross section for photon-photon annihilation to electron-positron pair. Masses and momenta are normalised by the rest mass of the electron <span>$m_{\text{Ele}}$</span> and the cross section is normalised by <span>$3σ_T$</span>.</p><p class="math-container">\[σ = \frac{1}{2s^3}\left((s^2+4s-8)\log\left(\frac{\sqrt(s)+\sqrt(s-4)}{\sqrt(s)-\sqrt(s-4)}\right)-(s+4)\sqrt{s(s-4)}\right)\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float32</code> : <span>$s - sBig$</span></li><li><code>sBig::Float32</code> : <span>$(m_1+m_2)^2 = 0 ∴ s = sSmol$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/DifferentialCrossSectionFunctions.jl#L147-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.sigma_SphSphSphSph-Tuple{Float32, Float32}" href="#BoltzmannCollisionIntegral.sigma_SphSphSphSph-Tuple{Float32, Float32}"><code>BoltzmannCollisionIntegral.sigma_SphSphSphSph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sigma_SphSphSphSph(sSmol,sBig)</code></pre><p>returns the total cross section for the binary interaction of hard spheres with normalised masses (wrt electron mass) <span>$m_1,m_2,m_3,m_4=m_\text{Sph}$</span>. Normalised by <span>$πR_{Sph}^2$</span>.</p><p class="math-container">\[σ = \frac{1}{2}\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float32</code> : s - sBig</li><li><code>sBig::Float32</code> : (m1+m2)^2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/DifferentialCrossSectionFunctions.jl#L40-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.trange-Tuple{Int64}" href="#BoltzmannCollisionIntegral.trange-Tuple{Int64}"><code>BoltzmannCollisionIntegral.trange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trange(numt)</code></pre><p>Returns a <code>numt+1</code> long <code>Vector{Float32}</code> of theta-space grid bounds in terms of cos(theta). Upper and lower bounds [tl tu] are defined as CONST in Init.jl as [-1f0 1f0].</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trange(8)
9-element Vector{Float32}:
 -1.0
 -0.75
 -0.5
 -0.25
  0.0
  0.25
  0.5
  0.75
  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/UsefulGridValueFunctions.jl#L50-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BoltzmannCollisionIntegral.vectorLocation-Tuple{Float32, Float32, Int64, Int64, Vector{Float32}}" href="#BoltzmannCollisionIntegral.vectorLocation-Tuple{Float32, Float32, Int64, Int64, Vector{Float32}}"><code>BoltzmannCollisionIntegral.vectorLocation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vectorLocation(pu,pl,nump,numt,vector)</code></pre><p>Returns a tuple of bin location for (log10momentum,cos(theta)) based on an input &#39;vector&#39; and bounds &#39;u,l&#39; of their domains and the &#39;num&#39; of uniformly spaced bins. costheta bounds [tl tu] are defined as CONST in Init.jl</p><p><strong>Examples</strong></p><p>```julia-repl julia&gt; vectorLocation(4f0,-5f0,9,8,[1f0,0.5f0,1.5f0]) (5,6)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/55bec8b7e31e93f3f1c8ace07fe739066cd0d8d2/src/Common/Location.jl#L55-L65">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../crosssections/">« Cross Sections</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Tuesday 23 July 2024 12:52">Tuesday 23 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
